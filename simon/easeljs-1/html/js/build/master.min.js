(function () {
	var lastTime = 0;
	var vendors = ["ms", "moz", "webkit", "o"];
	for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
		window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"]
	}
	if (!window.requestAnimationFrame)window.requestAnimationFrame = function (callback, element) {
		var currTime = (new Date).getTime();
		var timeToCall = Math.max(0, 16 - (currTime - lastTime));
		var id = window.setTimeout(function () {
			callback(currTime + timeToCall)
		}, timeToCall);
		lastTime = currTime + timeToCall;
		return id
	};
	if (!window.cancelAnimationFrame)window.cancelAnimationFrame = function (id) {
		clearTimeout(id)
	}
})();
(function (window, document, undefined) {
	var L = {version: "0.8-dev"};

	function expose() {
		var oldL = window.L;
		L.noConflict = function () {
			window.L = oldL;
			return this
		};
		window.L = L
	}

	if (typeof module === "object" && typeof module.exports === "object") {
		module.exports = L
	} else if (typeof define === "function" && define.amd) {
		define(L)
	} else {
		expose()
	}
	L.Util = {extend: function (dest) {
		var sources = Array.prototype.slice.call(arguments, 1), i, j, len, src;
		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j];
			for (i in src) {
				dest[i] = src[i]
			}
		}
		return dest
	}, create: Object.create || function () {
		function F() {
		}

		return function (proto) {
			F.prototype = proto;
			return new F
		}
	}(), bind: function (fn, obj) {
		var slice = Array.prototype.slice;
		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1))
		}
		var args = slice.call(arguments, 2);
		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments)
		}
	}, stamp: function (obj) {
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id
	}, lastId: 0, throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;
		later = function () {
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false
			}
		};
		wrapperFn = function () {
			if (lock) {
				args = arguments
			} else {
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true
			}
		};
		return wrapperFn
	}, wrapNum: function (x, range, includeMax) {
		var max = range[1], min = range[0], d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min
	}, falseFn: function () {
		return false
	}, formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow
	}, trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
	}, splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/)
	}, setOptions: function (obj, options) {
		if (!obj.hasOwnProperty("options")) {
			obj.options = obj.options ? L.Util.create(obj.options) : {}
		}
		for (var i in options) {
			obj.options[i] = options[i]
		}
		return obj.options
	}, getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]))
		}
		return(!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&")
	}, template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];
			if (value === undefined) {
				throw new Error("No value provided for variable " + str)
			} else if (typeof value === "function") {
				value = value(data)
			}
			return value
		})
	}, templateRe: /\{ *([\w_]+) *\}/g, isArray: Array.isArray || function (obj) {
		return Object.prototype.toString.call(obj) === "[object Array]"
	}, emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="};
	(function () {
		function getPrefixed(name) {
			return window["webkit" + name] || window["moz" + name] || window["ms" + name]
		}

		var lastTime = 0;

		function timeoutDefer(fn) {
			var time = +new Date, timeToCall = Math.max(0, 16 - (time - lastTime));
			lastTime = time + timeToCall;
			return window.setTimeout(fn, timeToCall)
		}

		var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer, cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function (id) {
			window.clearTimeout(id)
		};
		L.Util.requestAnimFrame = function (fn, context, immediate, element) {
			if (immediate && requestFn === timeoutDefer) {
				fn.call(context)
			} else {
				return requestFn.call(window, L.bind(fn, context), element)
			}
		};
		L.Util.cancelAnimFrame = function (id) {
			if (id) {
				cancelFn.call(window, id)
			}
		}
	})();
	L.extend = L.Util.extend;
	L.bind = L.Util.bind;
	L.stamp = L.Util.stamp;
	L.setOptions = L.Util.setOptions;
	L.Class = function () {
	};
	L.Class.extend = function (props) {
		var NewClass = function () {
			if (this.initialize) {
				this.initialize.apply(this, arguments)
			}
			if (this._initHooks.length) {
				this.callInitHooks()
			}
		};
		var parentProto = NewClass.__super__ = this.prototype;
		var proto = L.Util.create(parentProto);
		proto.constructor = NewClass;
		NewClass.prototype = proto;
		for (var i in this) {
			if (this.hasOwnProperty(i) && i !== "prototype") {
				NewClass[i] = this[i]
			}
		}
		if (props.statics) {
			L.extend(NewClass, props.statics);
			delete props.statics
		}
		if (props.includes) {
			L.Util.extend.apply(null, [proto].concat(props.includes));
			delete props.includes
		}
		if (proto.options) {
			props.options = L.Util.extend(L.Util.create(proto.options), props.options)
		}
		L.extend(proto, props);
		proto._initHooks = [];
		proto.callInitHooks = function () {
			if (this._initHooksCalled) {
				return
			}
			if (parentProto.callInitHooks) {
				parentProto.callInitHooks.call(this)
			}
			this._initHooksCalled = true;
			for (var i = 0, len = proto._initHooks.length; i < len; i++) {
				proto._initHooks[i].call(this)
			}
		};
		return NewClass
	};
	L.Class.include = function (props) {
		L.extend(this.prototype, props)
	};
	L.Class.mergeOptions = function (options) {
		L.extend(this.prototype.options, options)
	};
	L.Class.addInitHook = function (fn) {
		var args = Array.prototype.slice.call(arguments, 1);
		var init = typeof fn === "function" ? fn : function () {
			this[fn].apply(this, args)
		};
		this.prototype._initHooks = this.prototype._initHooks || [];
		this.prototype._initHooks.push(init)
	};
	L.Evented = L.Class.extend({on: function (types, fn, context) {
		if (typeof types === "object") {
			for (var type in types) {
				this._on(type, types[type], fn)
			}
		} else {
			types = L.Util.splitWords(types);
			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context)
			}
		}
		return this
	}, off: function (types, fn, context) {
		if (!types) {
			delete this._events
		} else if (typeof types === "object") {
			for (var type in types) {
				this._off(type, types[type], fn)
			}
		} else {
			types = L.Util.splitWords(types);
			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context)
			}
		}
		return this
	}, _on: function (type, fn, context) {
		var events = this._events = this._events || {}, contextId = context && context !== this && L.stamp(context);
		if (contextId) {
			var indexKey = type + "_idx", indexLenKey = type + "_len", typeIndex = events[indexKey] = events[indexKey] || {}, id = L.stamp(fn) + "_" + contextId;
			if (!typeIndex[id]) {
				typeIndex[id] = {fn: fn, ctx: context};
				events[indexLenKey] = (events[indexLenKey] || 0) + 1
			}
		} else {
			events[type] = events[type] || [];
			events[type].push({fn: fn})
		}
	}, _off: function (type, fn, context) {
		var events = this._events, indexKey = type + "_idx", indexLenKey = type + "_len";
		if (!events) {
			return
		}
		if (!fn) {
			delete events[type];
			delete events[indexKey];
			delete events[indexLenKey];
			return
		}
		var contextId = context && context !== this && L.stamp(context), listeners, i, len, listener, id;
		if (contextId) {
			id = L.stamp(fn) + "_" + contextId;
			listeners = events[indexKey];
			if (listeners && listeners[id]) {
				listener = listeners[id];
				delete listeners[id];
				events[indexLenKey]--
			}
		} else {
			listeners = events[type];
			for (i = 0, len = listeners.length; i < len; i++) {
				if (listeners[i].fn === fn) {
					listener = listeners[i];
					listeners.splice(i, 1);
					break
				}
			}
		}
		if (listener) {
			listener.fn = L.Util.falseFn
		}
	}, fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) {
			return this
		}
		var event = L.Util.extend({}, data, {type: type, target: this}), events = this._events;
		if (events) {
			var typeIndex = events[type + "_idx"], i, len, listeners, id;
			if (events[type]) {
				listeners = events[type].slice();
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn.call(this, event)
				}
			}
			for (id in typeIndex) {
				typeIndex[id].fn.call(typeIndex[id].ctx, event)
			}
		}
		if (propagate) {
			this._propagateEvent(event)
		}
		return this
	}, listens: function (type, propagate) {
		var events = this._events;
		if (events && (events[type] || events[type + "_len"])) {
			return true
		}
		if (propagate) {
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type)) {
					return true
				}
			}
		}
		return false
	}, once: function (types, fn, context) {
		if (typeof types === "object") {
			for (var type in types) {
				this.once(type, types[type], fn)
			}
			return this
		}
		var handler = L.bind(function () {
			this.off(types, fn, context).off(types, handler, context)
		}, this);
		return this.on(types, fn, context).on(types, handler, context)
	}, addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this
	}, removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)]
		}
		return this
	}, _propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e))
		}
	}});
	var proto = L.Evented.prototype;
	proto.addEventListener = proto.on;
	proto.removeEventListener = proto.clearAllEventListeners = proto.off;
	proto.addOneTimeEventListener = proto.once;
	proto.fireEvent = proto.fire;
	proto.hasEventListeners = proto.listens;
	L.Mixin = {Events: proto};
	(function () {
		var ua = navigator.userAgent.toLowerCase(), doc = document.documentElement, ie = "ActiveXObject"in window, webkit = ua.indexOf("webkit") !== -1, phantomjs = ua.indexOf("phantom") !== -1, android23 = ua.search("android [23]") !== -1, mobile = typeof orientation !== "undefined", msPointer = navigator.msPointerEnabled && navigator.msMaxTouchPoints && !window.PointerEvent, pointer = window.PointerEvent && navigator.pointerEnabled && navigator.maxTouchPoints || msPointer, ie3d = ie && "transition"in doc.style, webkit3d = "WebKitCSSMatrix"in window && "m11"in new window.WebKitCSSMatrix && !android23, gecko3d = "MozPerspective"in doc.style, opera3d = "OTransition"in doc.style;
		var retina = "devicePixelRatio"in window && window.devicePixelRatio > 1;
		if (!retina && "matchMedia"in window) {
			var matches = window.matchMedia("(min-resolution:144dpi)");
			retina = matches && matches.matches
		}
		var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || "ontouchstart"in window || window.DocumentTouch && document instanceof window.DocumentTouch);
		if (window.UsingDesktopTouchscreen) {
			touch = true
		}
		L.Browser = {ie: ie, ielt9: ie && !document.addEventListener, webkit: webkit, gecko: ua.indexOf("gecko") !== -1 && !webkit && !window.opera && !ie, android: ua.indexOf("android") !== -1, android23: android23, chrome: ua.indexOf("chrome") !== -1, ie3d: ie3d, webkit3d: webkit3d, gecko3d: gecko3d, opera3d: opera3d, any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs, mobile: mobile, mobileWebkit: mobile && webkit, mobileWebkit3d: mobile && webkit3d, mobileOpera: mobile && window.opera, touch: !!touch, msPointer: !!msPointer, pointer: !!pointer, retina: !!retina}
	})();
	L.Point = function (x, y, round) {
		this.x = round ? Math.round(x) : x;
		this.y = round ? Math.round(y) : y
	};
	L.Point.prototype = {clone: function () {
		return new L.Point(this.x, this.y)
	}, add: function (point) {
		return this.clone()._add(L.point(point))
	}, _add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this
	}, subtract: function (point) {
		return this.clone()._subtract(L.point(point))
	}, _subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this
	}, divideBy: function (num) {
		return this.clone()._divideBy(num)
	}, _divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this
	}, multiplyBy: function (num) {
		return this.clone()._multiplyBy(num)
	}, _multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this
	}, round: function () {
		return this.clone()._round()
	}, _round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this
	}, floor: function () {
		return this.clone()._floor()
	}, _floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this
	}, ceil: function () {
		return this.clone()._ceil()
	}, _ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this
	}, distanceTo: function (point) {
		point = L.point(point);
		var x = point.x - this.x, y = point.y - this.y;
		return Math.sqrt(x * x + y * y)
	}, equals: function (point) {
		point = L.point(point);
		return point.x === this.x && point.y === this.y
	}, contains: function (point) {
		point = L.point(point);
		return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y)
	}, toString: function () {
		return"Point(" + L.Util.formatNum(this.x) + ", " + L.Util.formatNum(this.y) + ")"
	}};
	L.point = function (x, y, round) {
		if (x instanceof L.Point) {
			return x
		}
		if (L.Util.isArray(x)) {
			return new L.Point(x[0], x[1])
		}
		if (x === undefined || x === null) {
			return x
		}
		return new L.Point(x, y, round)
	};
	L.Bounds = function (a, b) {
		if (!a) {
			return
		}
		var points = b ? [a, b] : a;
		for (var i = 0, len = points.length; i < len; i++) {
			this.extend(points[i])
		}
	};
	L.Bounds.prototype = {extend: function (point) {
		point = L.point(point);
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone()
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y)
		}
		return this
	}, getCenter: function (round) {
		return new L.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round)
	}, getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y)
	}, getTopRight: function () {
		return new L.Point(this.max.x, this.min.y)
	}, getSize: function () {
		return this.max.subtract(this.min)
	}, contains: function (obj) {
		var min, max;
		if (typeof obj[0] === "number" || obj instanceof L.Point) {
			obj = L.point(obj)
		} else {
			obj = L.bounds(obj)
		}
		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max
		} else {
			min = max = obj
		}
		return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y
	}, intersects: function (bounds) {
		bounds = L.bounds(bounds);
		var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
		return xIntersects && yIntersects
	}, isValid: function () {
		return!!(this.min && this.max)
	}};
	L.bounds = function (a, b) {
		if (!a || a instanceof L.Bounds) {
			return a
		}
		return new L.Bounds(a, b)
	};
	L.Transformation = function (a, b, c, d) {
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d
	};
	L.Transformation.prototype = {transform: function (point, scale) {
		return this._transform(point.clone(), scale)
	}, _transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point
	}, untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c)
	}};
	L.DomUtil = {get: function (id) {
		return typeof id === "string" ? document.getElementById(id) : id
	}, getStyle: function (el, style) {
		var value = el.style[style] || el.currentStyle && el.currentStyle[style];
		if ((!value || value === "auto") && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null
		}
		return value === "auto" ? null : value
	}, create: function (tagName, className, container) {
		var el = document.createElement(tagName);
		el.className = className;
		if (container) {
			container.appendChild(el)
		}
		return el
	}, remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el)
		}
	}, toFront: function (el) {
		el.parentNode.appendChild(el)
	}, toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild)
	}, hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name)
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className)
	}, addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i])
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + " " : "") + name)
		}
	}, removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name)
		} else {
			L.DomUtil.setClass(el, L.Util.trim((" " + L.DomUtil.getClass(el) + " ").replace(" " + name + " ", " ")))
		}
	}, setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name
		} else {
			el.className.baseVal = name
		}
	}, getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal
	}, setOpacity: function (el, value) {
		if ("opacity"in el.style) {
			el.style.opacity = value
		} else if ("filter"in el.style) {
			var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
			try {
				filter = el.filters.item(filterName)
			} catch (e) {
				if (value === 1) {
					return
				}
			}
			value = Math.round(value * 100);
			if (filter) {
				filter.Enabled = value !== 100;
				filter.Opacity = value
			} else {
				el.style.filter += " progid:" + filterName + "(opacity=" + value + ")"
			}
		}
	}, testProp: function (props) {
		var style = document.documentElement.style;
		for (var i = 0; i < props.length; i++) {
			if (props[i]in style) {
				return props[i]
			}
		}
		return false
	}, setTransform: function (el, offset, scale) {
		var is3d = L.Browser.webkit3d, pos = offset || new L.Point(0, 0);
		el.style[L.DomUtil.TRANSFORM] = "translate" + (is3d ? "3d(" : "(") + pos.x + "px," + pos.y + "px" + (is3d ? ",0)" : ")") + (scale ? " scale(" + scale + ")" : "")
	}, setPosition: function (el, point, disable3D) {
		el._leaflet_pos = point;
		if (!disable3D && L.Browser.any3d) {
			L.DomUtil.setTransform(el, point)
		} else {
			el.style.left = point.x + "px";
			el.style.top = point.y + "px"
		}
	}, getPosition: function (el) {
		return el._leaflet_pos
	}};
	(function () {
		L.DomUtil.TRANSFORM = L.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]);
		var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
		L.DomUtil.TRANSITION_END = transition === "webkitTransition" || transition === "OTransition" ? transition + "End" : "transitionend";
		if ("onselectstart"in document) {
			L.DomUtil.disableTextSelection = function () {
				L.DomEvent.on(window, "selectstart", L.DomEvent.preventDefault)
			};
			L.DomUtil.enableTextSelection = function () {
				L.DomEvent.off(window, "selectstart", L.DomEvent.preventDefault)
			}
		} else {
			var userSelectProperty = L.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
			L.DomUtil.disableTextSelection = function () {
				if (userSelectProperty) {
					var style = document.documentElement.style;
					this._userSelect = style[userSelectProperty];
					style[userSelectProperty] = "none"
				}
			};
			L.DomUtil.enableTextSelection = function () {
				if (userSelectProperty) {
					document.documentElement.style[userSelectProperty] = this._userSelect;
					delete this._userSelect
				}
			}
		}
		L.DomUtil.disableImageDrag = function () {
			L.DomEvent.on(window, "dragstart", L.DomEvent.preventDefault)
		};
		L.DomUtil.enableImageDrag = function () {
			L.DomEvent.off(window, "dragstart", L.DomEvent.preventDefault)
		}
	})();
	L.LatLng = function (lat, lng, alt) {
		if (isNaN(lat) || isNaN(lng)) {
			throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")")
		}
		this.lat = +lat;
		this.lng = +lng;
		if (alt !== undefined) {
			this.alt = +alt
		}
	};
	L.LatLng.prototype = {equals: function (obj, maxMargin) {
		if (!obj) {
			return false
		}
		obj = L.latLng(obj);
		var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
		return margin <= (maxMargin === undefined ? 1e-9 : maxMargin)
	}, toString: function (precision) {
		return"LatLng(" + L.Util.formatNum(this.lat, precision) + ", " + L.Util.formatNum(this.lng, precision) + ")"
	}, distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other))
	}};
	L.latLng = function (a, b) {
		if (a instanceof L.LatLng) {
			return a
		}
		if (L.Util.isArray(a) && typeof a[0] !== "object") {
			if (a.length === 3) {
				return new L.LatLng(a[0], a[1], a[2])
			}
			return new L.LatLng(a[0], a[1])
		}
		if (a === undefined || a === null) {
			return a
		}
		if (typeof a === "object" && "lat"in a) {
			return new L.LatLng(a.lat, "lng"in a ? a.lng : a.lon)
		}
		if (b === undefined) {
			return null
		}
		return new L.LatLng(a, b)
	};
	L.LatLngBounds = function (southWest, northEast) {
		if (!southWest) {
			return
		}
		var latlngs = northEast ? [southWest, northEast] : southWest;
		for (var i = 0, len = latlngs.length; i < len; i++) {
			this.extend(latlngs[i])
		}
	};
	L.LatLngBounds.prototype = {extend: function (obj) {
		if (!obj) {
			return this
		}
		var latLng = L.latLng(obj);
		if (latLng !== null) {
			obj = latLng
		} else {
			obj = L.latLngBounds(obj)
		}
		if (obj instanceof L.LatLng) {
			if (!this._southWest && !this._northEast) {
				this._southWest = new L.LatLng(obj.lat, obj.lng);
				this._northEast = new L.LatLng(obj.lat, obj.lng)
			} else {
				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);
				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
				this._northEast.lng = Math.max(obj.lng, this._northEast.lng)
			}
		} else if (obj instanceof L.LatLngBounds) {
			this.extend(obj._southWest);
			this.extend(obj._northEast)
		}
		return this
	}, pad: function (bufferRatio) {
		var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
		return new L.LatLngBounds(new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer))
	}, getCenter: function () {
		return new L.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
	}, getSouthWest: function () {
		return this._southWest
	}, getNorthEast: function () {
		return this._northEast
	}, getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest())
	}, getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast())
	}, getWest: function () {
		return this._southWest.lng
	}, getSouth: function () {
		return this._southWest.lat
	}, getEast: function () {
		return this._northEast.lng
	}, getNorth: function () {
		return this._northEast.lat
	}, contains: function (obj) {
		if (typeof obj[0] === "number" || obj instanceof L.LatLng) {
			obj = L.latLng(obj)
		} else {
			obj = L.latLngBounds(obj)
		}
		var sw = this._southWest, ne = this._northEast, sw2, ne2;
		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast()
		} else {
			sw2 = ne2 = obj
		}
		return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng
	}, intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);
		var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
		return latIntersects && lngIntersects
	}, toBBoxString: function () {
		return[this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
	}, equals: function (bounds) {
		if (!bounds) {
			return false
		}
		bounds = L.latLngBounds(bounds);
		return this._southWest.equals(bounds.getSouthWest()) && this._northEast.equals(bounds.getNorthEast())
	}, isValid: function () {
		return!!(this._southWest && this._northEast)
	}};
	L.latLngBounds = function (a, b) {
		if (!a || a instanceof L.LatLngBounds) {
			return a
		}
		return new L.LatLngBounds(a, b)
	};
	L.Projection = {};
	L.Projection.LonLat = {project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat)
	}, unproject: function (point) {
		return new L.LatLng(point.y, point.x)
	}, bounds: L.bounds([-180, -90], [180, 90])};
	L.Projection.SphericalMercator = {R: 6378137, project: function (latlng) {
		var d = Math.PI / 180, max = 1 - 1e-15, sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);
		return new L.Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2)
	}, unproject: function (point) {
		var d = 180 / Math.PI;
		return new L.LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R)
	}, bounds: function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d])
	}()};
	L.CRS = {latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);
		return this.transformation._transform(projectedPoint, scale)
	}, pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);
		return this.projection.unproject(untransformedPoint)
	}, project: function (latlng) {
		return this.projection.project(latlng)
	}, unproject: function (point) {
		return this.projection.unproject(point)
	}, scale: function (zoom) {
		return 256 * Math.pow(2, zoom)
	}, getProjectedBounds: function (zoom) {
		if (this.infinite) {
			return null
		}
		var b = this.projection.bounds, s = this.scale(zoom), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
		return L.bounds(min, max)
	}, wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat;
		return L.latLng(lat, lng)
	}};
	L.CRS.Simple = L.extend({}, L.CRS, {projection: L.Projection.LonLat, transformation: new L.Transformation(1, 0, -1, 0), scale: function (zoom) {
		return Math.pow(2, zoom)
	}, distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
		return Math.sqrt(dx * dx + dy * dy)
	}, infinite: true});
	L.CRS.Earth = L.extend({}, L.CRS, {wrapLng: [-180, 180], R: 6378137, distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad;
		return this.R * Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad))
	}});
	L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {code: "EPSG:3857", projection: L.Projection.SphericalMercator, transformation: function () {
		var scale = .5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, .5, -scale, .5)
	}()});
	L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {code: "EPSG:900913"});
	L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {code: "EPSG:4326", projection: L.Projection.LonLat, transformation: new L.Transformation(1 / 180, 1, -1 / 180, .5)});
	L.Map = L.Evented.extend({options: {crs: L.CRS.EPSG3857, fadeAnimation: true, trackResize: true, markerZoomAnimation: true, scrollWheelFractionalZoom: true, touchFractionalZoom: true}, initialize: function (id, options) {
		options = L.setOptions(this, options);
		this._initContainer(id);
		this._initLayout();
		this._onResize = L.bind(this._onResize, this);
		this._initEvents();
		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds)
		}
		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true})
		}
		this.windowMinZoom = this.getMinZoom();
		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this.callInitHooks();
		this._addLayers(this.options.layers)
	}, setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this
	}, setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this
		}
		return this.setView(this.getCenter(), zoom, {zoom: options})
	}, zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options)
	}, zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options)
	}, setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
		return this.setView(newCenter, zoom, {zoom: options})
	}, fitBounds: function (bounds, options) {
		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);
		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)), paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
		this.windowMinZoom = zoom + 1;
		return this.setView(center, this.windowMinZoom, options)
	}, fitWorld: function (options) {
		return this.fitBounds([
			[-90, -180],
			[90, 180]
		], options)
	}, panTo: function (center, options) {
		return this.setView(center, this._zoom, {pan: options})
	}, panBy: function (offset) {
		this.fire("movestart");
		this._rawPanBy(L.point(offset));
		this.fire("move");
		return this.fire("moveend")
	}, setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);
		this.options.maxBounds = bounds;
		if (!bounds) {
			return this.off("moveend", this._panInsideMaxBounds)
		}
		if (this._loaded) {
			this._panInsideMaxBounds()
		}
		return this.on("moveend", this._panInsideMaxBounds)
	}, panInsideBounds: function (bounds, options) {
		var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, bounds);
		if (center.equals(newCenter)) {
			return this
		}
		return this.panTo(newCenter, options)
	}, invalidateSize: function (options) {
		if (!this._loaded) {
			return this
		}
		options = L.extend({animate: false, pan: true}, options === true ? {animate: true} : options);
		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;
		var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
		if (!offset.x && !offset.y) {
			return this
		}
		if (options.animate && options.pan) {
			this.panBy(offset)
		} else {
			if (options.pan) {
				this._rawPanBy(offset)
			}
			this.fire("move");
			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, "moveend"), 200)
			} else {
				this.fire("moveend")
			}
		}
		return this.fire("resize", {oldSize: oldSize, newSize: newSize})
	}, addHandler: function (name, HandlerClass) {
		if (!HandlerClass) {
			return this
		}
		var handler = this[name] = new HandlerClass(this);
		this._handlers.push(handler);
		if (this.options[name]) {
			handler.enable()
		}
		return this
	}, remove: function () {
		if (this._loaded) {
			this.fire("unload")
		}
		this._initEvents("off");
		try {
			delete this._container._leaflet
		} catch (e) {
			this._container._leaflet = undefined
		}
		L.DomUtil.remove(this._mapPane);
		if (this._clearControlPos) {
			this._clearControlPos()
		}
		this._clearHandlers();
		return this
	}, createPane: function (name, container) {
		var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = L.DomUtil.create("div", className, container || this._mapPane);
		if (name) {
			this._panes[name] = pane
		}
		return pane
	}, getCenter: function () {
		this._checkIfLoaded();
		if (this._initialCenter && !this._moved()) {
			return this._initialCenter
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint())
	}, getZoom: function () {
		return this._zoom
	}, getBounds: function () {
		var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
		return new L.LatLngBounds(sw, ne)
	}, getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom
	}, getNewMinZoom: function () {
		return this.options.newMinZoom === undefined ? this.options.minZoom || 0 : this.options.newMinZoom
	}, getMaxZoom: function () {
		return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom
	}, getBoundsZoom: function (bounds, inside, padding) {
		bounds = L.latLngBounds(bounds);
		var actualZoom = zoom = this.getMinZoom() - (inside ? 1 : 0), maxZoom = this.getMaxZoom(), size = this.getSize(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), zoomNotFound = true, boundsSize;
		padding = L.point(padding || [0, 0]);
		do {
			zoom += .01;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y
		} while (zoomNotFound && zoom <= maxZoom);
		if (zoomNotFound && inside) {
			return null
		}
		return inside ? zoom : zoom - 1
	}, getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(this._container.clientWidth, this._container.clientHeight);
			this._sizeChanged = false
		}
		return this._size.clone()
	}, getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()))
	}, getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin
	}, getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom)
	}, getPane: function (pane) {
		return typeof pane === "string" ? this._panes[pane] : pane
	}, getPanes: function () {
		return this._panes
	}, getContainer: function () {
		return this._container
	}, getZoomScale: function (toZoom, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom)
	}, getScaleZoom: function (scale, fromZoom) {
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return fromZoom + Math.log(scale) / Math.LN2
	}, project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom)
	}, unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom)
	}, layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint)
	}, latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin())
	}, wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng))
	}, distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2))
	}, containerPointToLayerPoint: function (point) {
		return L.point(point).subtract(this._getMapPanePos())
	}, layerPointToContainerPoint: function (point) {
		return L.point(point).add(this._getMapPanePos())
	}, containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint)
	}, latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)))
	}, mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container)
	}, mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e))
	}, mouseEventToLatLng: function (e) {
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e))
	}, _initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);
		if (!container) {
			throw new Error("Map container not found.")
		} else if (container._leaflet) {
			throw new Error("Map container is already initialized.")
		}
		container._leaflet = true
	}, _initLayout: function () {
		var container = this._container;
		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;
		L.DomUtil.addClass(container, "leaflet-container" + (L.Browser.touch ? " leaflet-touch" : "") + (L.Browser.retina ? " leaflet-retina" : "") + (L.Browser.ielt9 ? " leaflet-oldie" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
		var position = L.DomUtil.getStyle(container, "position");
		if (position !== "absolute" && position !== "relative" && position !== "fixed") {
			container.style.position = "relative"
		}
		this._initPanes();
		if (this._initControlPos) {
			this._initControlPos()
		}
	}, _initPanes: function () {
		var panes = this._panes = {};
		this._mapPane = this.createPane("mapPane", this._container);
		this.createPane("tilePane");
		this.createPane("shadowPane");
		this.createPane("overlayPane");
		this.createPane("markerPane");
		this.createPane("popupPane");
		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, "leaflet-zoom-hide");
			L.DomUtil.addClass(panes.shadowPane, "leaflet-zoom-hide")
		}
	}, _resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {
		var zoomChanged = this._zoom !== zoom;
		if (!afterZoomAnim) {
			this.fire("movestart");
			if (zoomChanged) {
				this.fire("zoomstart")
			}
		}
		this._zoom = zoom;
		this._initialCenter = center;
		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0))
		}
		this._pixelOrigin = this._getNewPixelOrigin(center);
		if (!this._loaded) {
			this._loaded = true;
			this.fire("load")
		}
		this.fire("viewreset", {hard: !preserveMapOffset});
		this.fire("move");
		if (zoomChanged || afterZoomAnim) {
			this.fire("zoomend")
		}
		this.fire("moveend", {hard: !preserveMapOffset})
	}, _rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset))
	}, _getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom()
	}, _panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds)
	}, _checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error("Set map center and zoom first.")
		}
	}, _initEvents: function (onOff) {
		if (!L.DomEvent) {
			return
		}
		onOff = onOff || "on";
		L.DomEvent[onOff](this._container, "click dblclick mousedown mouseup mouseenter mouseleave mousemove contextmenu", this._handleMouseEvent, this);
		if (this.options.trackResize) {
			L.DomEvent[onOff](window, "resize", this._onResize, this)
		}
	}, _onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(function () {
			this.invalidateSize({debounceMoveend: true})
		}, this, false, this._container)
	}, _handleMouseEvent: function (e) {
		if (!this._loaded) {
			return
		}
		this._fireMouseEvent(this, e, e.type === "mouseenter" ? "mouseover" : e.type === "mouseleave" ? "mouseout" : e.type)
	}, _fireMouseEvent: function (obj, e, type, propagate, latlng) {
		type = type || e.type;
		if (type === "click") {
			if (!e._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved())) {
				return
			}
			obj.fire("preclick")
		}
		if (!obj.listens(type, propagate) || L.DomEvent._skipped(e)) {
			return
		}
		if (type === "contextmenu") {
			L.DomEvent.preventDefault(e)
		}
		if (type === "click" || type === "dblclick" || type === "contextmenu") {
			L.DomEvent.stopPropagation(e)
		}
		var data = {originalEvent: e, containerPoint: this.mouseEventToContainerPoint(e)};
		data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
		data.latlng = latlng || this.layerPointToLatLng(data.layerPoint);
		obj.fire(type, data, propagate)
	}, _clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable()
		}
	}, whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, this)
		} else {
			this.on("load", callback, context)
		}
		return this
	}, _getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0)
	}, _moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0])
	}, _getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos())
	}, _getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round()
	}, _latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft)
	}, _getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
	}, _getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint())
	}, _limitCenter: function (center, zoom, bounds) {
		if (!bounds) {
			return center
		}
		var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);
		return this.unproject(centerPoint.add(offset), zoom)
	}, _limitOffset: function (offset, bounds) {
		if (!bounds) {
			return offset
		}
		var viewBounds = this.getPixelBounds(), newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
		return offset.add(this._getBoundsOffset(newBounds, bounds))
	}, _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min), seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max), dx = this._rebound(nwOffset.x, -seOffset.x), dy = this._rebound(nwOffset.y, -seOffset.y);
		return new L.Point(dx, dy)
	}, _rebound: function (left, right) {
		return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right))
	}, _limitZoom: function (zoom) {
		var min = this.getNewMinZoom(), max = this.getMaxZoom();
		return Math.max(min, Math.min(max, zoom))
	}});
	L.map = function (id, options) {
		return new L.Map(id, options)
	};
	L.Layer = L.Evented.extend({options: {pane: "overlayPane"}, addTo: function (map) {
		var id = L.stamp(this);
		if (map._layers[id]) {
			return this
		}
		map._layers[id] = this;
		this._zoomAnimated = map._zoomAnimated;
		if (this.beforeAdd) {
			this.beforeAdd(map)
		}
		this._mapToAdd = map;
		map.whenReady(this._layerAdd, this);
		return this
	}, _layerAdd: function () {
		var map = this._mapToAdd;
		if (!map) {
			return
		}
		this._map = map;
		this._mapToAdd = null;
		this.onAdd(map);
		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution())
		}
		if (this.getEvents) {
			map.on(this.getEvents(), this)
		}
		this.fire("add");
		map.fire("layeradd", {layer: this})
	}, remove: function () {
		var id = L.stamp(this), map = this._map || this._mapToAdd;
		if (!map || !map._layers[id]) {
			return this
		}
		if (map._loaded) {
			this.onRemove(map)
		}
		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.removeAttribution(this.getAttribution())
		}
		if (this.getEvents) {
			map.off(this.getEvents(), this)
		}
		delete map._layers[id];
		if (map._loaded) {
			map.fire("layerremove", {layer: this});
			this.fire("remove")
		}
		this._map = this._mapToAdd = null;
		return this
	}, getPane: function (name) {
		return this._map.getPane(name ? this.options[name] || name : this.options.pane)
	}});
	L.Map.include({addLayer: function (layer) {
		layer.addTo(this);
		return this
	}, removeLayer: function (layer) {
		layer.remove();
		return this
	}, hasLayer: function (layer) {
		return!!layer && L.stamp(layer)in this._layers
	}, eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i])
		}
		return this
	}, _addLayers: function (layers) {
		layers = layers ? L.Util.isArray(layers) ? layers : [layers] : [];
		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i])
		}
	}, _addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels()
		}
	}, _removeZoomLimit: function (layer) {
		var id = L.stamp(layer);
		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels()
		}
	}, _updateZoomLevels: function () {
		var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;
			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom)
		}
		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire("zoomlevelschange")
		}
	}});
	L.Projection.Mercator = {R: 6378137, R_MINOR: 6356752.314245179, bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project: function (latlng) {
		var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1e-10));
		return new L.Point(latlng.lng * d * r, y)
	}, unproject: function (point) {
		var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
		for (var i = 0, dphi = .1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi
		}
		return new L.LatLng(phi * d, point.x * d / r)
	}};
	L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {code: "EPSG:3395", projection: L.Projection.Mercator, transformation: function () {
		var scale = .5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, .5, -scale, .5)
	}()});
	L.GridLayer = L.Layer.extend({options: {pane: "tilePane", tileSize: 256, opacity: 1, unloadInvisibleTiles: L.Browser.mobile, updateWhenIdle: L.Browser.mobile, updateInterval: 200}, initialize: function (options) {
		options = L.setOptions(this, options)
	}, onAdd: function () {
		this._initContainer();
		if (!this.options.updateWhenIdle) {
			this._update = L.Util.throttle(this._update, this.options.updateInterval, this)
		}
		this._levels = {};
		this._reset();
		this._update()
	}, beforeAdd: function (map) {
		map._addZoomLimit(this)
	}, onRemove: function (map) {
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null
	}, bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max)
		}
		return this
	}, bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min)
		}
		return this
	}, getAttribution: function () {
		return this.options.attribution
	}, getContainer: function () {
		return this._container
	}, setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity()
		}
		return this
	}, setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();
		return this
	}, redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update()
		}
		return this
	}, getEvents: function () {
		var events = {viewreset: this._reset, moveend: this._update};
		if (!this.options.updateWhenIdle) {
			events.move = this._update
		}
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom
		}
		return events
	}, _updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex
		}
	}, _setAutoZIndex: function (compare) {
		var layers = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
		for (var i = 0, len = layers.length, zIndex; i < len; i++) {
			zIndex = layers[i].style.zIndex;
			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex)
			}
		}
		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex()
		}
	}, _updateOpacity: function () {
		var opacity = this.options.opacity;
		if (L.Browser.ielt9) {
			for (var i in this._tiles) {
				L.DomUtil.setOpacity(this._tiles[i], opacity)
			}
		} else {
			L.DomUtil.setOpacity(this._container, opacity)
		}
	}, _initContainer: function () {
		if (this._container) {
			return
		}
		this._container = L.DomUtil.create("div", "leaflet-layer");
		this._updateZIndex();
		if (this.options.opacity < 1) {
			this._updateOpacity()
		}
		this.getPane().appendChild(this._container)
	}, _updateLevels: function () {
		var zoom = this._tileZoom;
		for (var z in this._levels) {
			z = parseInt(z, 10);
			if (z > zoom + 2 || z < zoom - 2) {
				this._destroyLevel(this._levels[z]);
				delete this._levels[z]
			} else {
				this._levels[z].el.style.zIndex = -Math.abs(zoom - z)
			}
		}
		var level = this._levels[zoom], map = this._map;
		if (!level) {
			level = this._levels[zoom] = {};
			level.el = L.DomUtil.create("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
			level.el.style.zIndex = 0;
			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;
			level.tiles = {}
		}
		this._level = level;
		return level
	}, _destroyLevel: function (level) {
		for (var i in level.tiles) {
			level.tiles[i].onload = null
		}
		L.DomUtil.remove(level.el)
	}, _reset: function (e) {
		var map = this._map, zoom = map.getZoom(), tileZoom = Math.round(zoom), tileZoomChanged = this._tileZoom !== tileZoom;
		if (tileZoomChanged || e && e.hard) {
			this._tileZoom = tileZoom;
			this._updateLevels();
			this._resetGrid()
		}
		this._setZoomTransforms(map.getCenter(), zoom)
	}, _setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom)
		}
	}, _setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();
		L.DomUtil.setTransform(level.el, translate, scale)
	}, _clearTiles: function () {
		for (var key in this._tiles) {
			this.fire("tileunload", {tile: this._tiles[key]})
		}
		this._tiles = {};
		this._tilesToLoad = 0;
		this._tilesTotal = 0;
		this._tileContainer.innerHTML = ""
	}, _resetGrid: function () {
		var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this._getTileSize(), tileZoom = this._tileZoom;
		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds)
		}
		this._wrapX = crs.wrapLng && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize)];
		this._wrapY = crs.wrapLat && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize)]
	}, _getTileSize: function () {
		return this.options.tileSize
	}, _update: function () {
		if (!this._map) {
			return
		}
		var tileRange = this._getTileRange(this._map.getBounds(), this._tileZoom);
		this._addTiles(tileRange)
	}, _getTileRange: function (bounds, zoom) {
		var pxBounds = new L.Bounds(this._map.project(bounds.getNorthWest(), zoom), this._map.project(bounds.getSouthEast(), zoom));
		return this._pxBoundsToTileRange(pxBounds)
	}, _addTiles: function (tileRange) {
		var queue = [], center = tileRange.getCenter();
		var j, i, coords;
		for (j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (i = tileRange.min.x; i <= tileRange.max.x; i++) {
				coords = new L.Point(i, j);
				coords.z = this._tileZoom;
				if (!(this._tileCoordsToKey(coords)in this._level.tiles) && this._isValidTile(coords)) {
					queue.push(coords)
				}
			}
		}
		var tilesToLoad = queue.length;
		if (tilesToLoad === 0) {
			return
		}
		if (!this._tilesToLoad) {
			this.fire("loading")
		}
		this._tilesToLoad += tilesToLoad;
		this._tilesTotal += tilesToLoad;
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center)
		});
		var fragment = document.createDocumentFragment();
		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment)
		}
		this._level.el.appendChild(fragment)
	}, _isValidTile: function (coords) {
		var crs = this._map.options.crs;
		if (!crs.infinite) {
			var bounds = this._globalTileRange;
			if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
				return false
			}
		}
		if (!this.options.bounds) {
			return true
		}
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).intersects(tileBounds)
	}, _tileCoordsToBounds: function (coords) {
		var map = this._map, tileSize = this.options.tileSize, nwPoint = coords.multiplyBy(tileSize), sePoint = nwPoint.add([tileSize, tileSize]), nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)), se = map.wrapLatLng(map.unproject(sePoint, coords.z));
		return new L.LatLngBounds(nw, se)
	}, _tileCoordsToKey: function (coords) {
		return coords.x + ":" + coords.y
	}, _keyToTileCoords: function (key) {
		var kArr = key.split(":"), x = parseInt(kArr[0], 10), y = parseInt(kArr[1], 10);
		return new L.Point(x, y)
	}, _removeOtherTiles: function (bounds) {
		for (var key in this._tiles) {
			if (!bounds.contains(this._keyToTileCoords(key))) {
				this._removeTile(key)
			}
		}
	}, _removeTile: function (key) {
		var tile = this._tiles[key];
		L.DomUtil.remove(tile);
		delete this._tiles[key];
		this.fire("tileunload", {tile: tile})
	}, _initTile: function (tile) {
		L.DomUtil.addClass(tile, "leaflet-tile");
		tile.style.width = this._tileSize + "px";
		tile.style.height = this._tileSize + "px";
		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity)
		}
		if (L.Browser.mobileWebkit3d) {
			tile.style.WebkitBackfaceVisibility = "hidden"
		}
	}, _addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
		this._wrapCoords(coords);
		var tile = this.createTile(coords, L.bind(this._tileReady, this));
		this._initTile(tile);
		if (this.createTile.length < 2) {
			setTimeout(L.bind(this._tileReady, this, null, tile), 0)
		}
		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);
		this._level.tiles[key] = tile;
		container.appendChild(tile);
		this.fire("tileloadstart", {tile: tile})
	}, _tileReady: function (err, tile) {
		if (err) {
			this.fire("tileerror", {error: err, tile: tile})
		} else {
			L.DomUtil.addClass(tile, "leaflet-tile-loaded");
			this.fire("tileload", {tile: tile})
		}
		this._tilesToLoad--;
		if (this._tilesToLoad === 0) {
			this.fire("load")
		}
	}, _getTilePos: function (coords) {
		return coords.multiplyBy(this._tileSize).subtract(this._level.origin)
	}, _wrapCoords: function (coords) {
		coords.x = this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x;
		coords.y = this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y
	}, _pxBoundsToTileRange: function (bounds) {
		return new L.Bounds(bounds.min.divideBy(this._tileSize).floor(), bounds.max.divideBy(this._tileSize).ceil().subtract([1, 1]))
	}, _animateZoom: function (e) {
		this._setZoomTransforms(e.center, e.zoom)
	}});
	L.gridLayer = function (options) {
		return new L.GridLayer(options)
	};
	L.TileLayer = L.GridLayer.extend({options: {minZoom: 0, maxZoom: 18, subdomains: "abc", zoomOffset: 0}, initialize: function (url, options) {
		this._url = url;
		options = L.setOptions(this, options);
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {
			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;
			options.minZoom = Math.max(0, options.minZoom);
			options.maxZoom--
		}
		if (typeof options.subdomains === "string") {
			options.subdomains = options.subdomains.split("")
		}
		if (!L.Browser.android) {
			this.on("tileunload", this._onTileRemove)
		}
	}, setUrl: function (url, noRedraw) {
		this._url = url;
		if (!noRedraw) {
			this.redraw()
		}
		return this
	}, createTile: function (coords, done) {
		var tile = document.createElement("img");
		tile.onload = L.bind(this._tileOnLoad, this, done, tile);
		tile.onerror = L.bind(this._tileOnError, this, done, tile);
		tile.src = this.getTileUrl(coords);
		return tile
	}, getTileUrl: function (coords) {
		return L.Util.template(this._url, L.extend({r: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? "@2x" : "", s: this._getSubdomain(coords), x: coords.x, y: this.options.tms ? this._tileNumBounds.max.y - coords.y : coords.y, z: this._getZoomForUrl()}, this.options))
	}, _tileOnLoad: function (done, tile) {
		done(null, tile)
	}, _tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl
		}
		done(e, tile)
	}, _getTileSize: function () {
		var map = this._map, options = this.options, zoom = map.getZoom() + options.zoomOffset, zoomN = options.maxNativeZoom;
		return zoomN && zoom > zoomN ? Math.round(map.getZoomScale(zoomN, zoom) * options.tileSize) : options.tileSize
	}, _onTileRemove: function (e) {
		e.tile.onload = null;
		e.tile.src = L.Util.emptyImageUrl;
		console.log("hello")
	}, _getZoomForUrl: function () {
		var options = this.options, zoom = this._tileZoom;
		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom
		}
		zoom += options.zoomOffset;
		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom
	}, _getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index]
	}, _abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			tile = this._tiles[i];
			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;
				L.DomUtil.remove(tile)
			}
		}
	}});
	L.tileLayer = function (url, options) {
		return new L.TileLayer(url, options)
	};
	L.TileLayer.WMS = L.TileLayer.extend({defaultWmsParams: {service: "WMS", request: "GetMap", version: "1.1.1", layers: "", styles: "", format: "image/jpeg", transparent: false}, initialize: function (url, options) {
		this._url = url;
		var wmsParams = L.extend({}, this.defaultWmsParams);
		for (var i in options) {
			if (!this.options.hasOwnProperty(i) && i !== "crs") {
				wmsParams[i] = options[i]
			}
		}
		options = L.setOptions(this, options);
		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);
		this.wmsParams = wmsParams
	}, onAdd: function (map) {
		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);
		var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
		this.wmsParams[projectionKey] = this._crs.code;
		L.TileLayer.prototype.onAdd.call(this, map)
	}, getTileUrl: function (coords) {
		var tileBounds = this._tileCoordsToBounds(coords), nw = this._crs.project(tileBounds.getNorthWest()), se = this._crs.project(tileBounds.getSouthEast()), bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(","), url = L.Util.template(this._url, {s: this._getSubdomain(coords)});
		return url + L.Util.getParamString(this.wmsParams, url, true) + "&BBOX=" + bbox
	}, setParams: function (params, noRedraw) {
		L.extend(this.wmsParams, params);
		if (!noRedraw) {
			this.redraw()
		}
		return this
	}});
	L.tileLayer.wms = function (url, options) {
		return new L.TileLayer.WMS(url, options)
	};
	L.ImageOverlay = L.Layer.extend({options: {opacity: 1}, initialize: function (url, bounds, options) {
		this._url = url;
		this._bounds = L.latLngBounds(bounds);
		if (options.customClassName !== undefined) {
			this.customClassName = options.customClassName;
			console.log("ImageOverlay init with " + this.customClassName)
		}
		L.setOptions(this, options)
	}, onAdd: function () {
		if (!this._image) {
			this._initImage();
			if (this.options.opacity < 1) {
				this._updateOpacity()
			}
		}
		this.getPane().appendChild(this._image);
		this._reset()
	}, onRemove: function () {
		L.DomUtil.remove(this._image)
	}, setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._image) {
			this._updateOpacity()
		}
		return this
	}, bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image)
		}
		return this
	}, bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image)
		}
		return this
	}, setUrl: function (url) {
		this._url = url;
		if (this._image) {
			this._image.src = url
		}
		return this
	}, getAttribution: function () {
		return this.options.attribution
	}, getEvents: function () {
		var events = {viewreset: this._reset};
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom
		}
		return events
	}, _initImage: function () {
		var img = this._image = L.DomUtil.create("img", "leaflet-image-layer " + (this._zoomAnimated ? "leaflet-zoom-animated" : "") + (this.customClassName ? " " + this.customClassName : ""));
		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;
		img.onload = L.bind(this.fire, this, "load");
		img.src = this._url
	}, _animateZoom: function (e) {
		var topLeft = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center), size = this._map._latLngToNewLayerPoint(this._bounds.getSouthEast(), e.zoom, e.center).subtract(topLeft), offset = topLeft.add(size._multiplyBy((1 - 1 / e.scale) / 2));
		L.DomUtil.setTransform(this._image, offset, e.scale)
	}, _reset: function () {
		var image = this._image, bounds = new L.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
		L.DomUtil.setPosition(image, bounds.min);
		image.style.width = size.x + "px";
		image.style.height = size.y + "px"
	}, _updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity)
	}});
	L.imageOverlay = function (url, bounds, options) {
		return new L.ImageOverlay(url, bounds, options)
	};
	L.Icon = L.Class.extend({initialize: function (options) {
		L.setOptions(this, options)
	}, createIcon: function (oldIcon) {
		return this._createIcon("icon", oldIcon)
	}, createShadow: function (oldIcon) {
		return this._createIcon("shadow", oldIcon)
	}, _createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);
		if (!src) {
			if (name === "icon") {
				throw new Error("iconUrl not set in Icon options (see the docs).")
			}
			return null
		}
		var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
		this._setIconStyles(img, name);
		return img
	}, _setIconStyles: function (img, name) {
		var options = this.options, size = L.point(options[name + "Size"]), anchor = L.point(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
		img.className = "leaflet-marker-" + name + " " + (options.className || "");
		if (anchor) {
			img.style.marginLeft = -anchor.x + "px";
			img.style.marginTop = -anchor.y + "px"
		}
		if (size) {
			img.style.width = size.x + "px";
			img.style.height = size.y + "px"
		}
	}, _createImg: function (src, el) {
		el = el || document.createElement("img");
		el.src = src;
		return el
	}, _getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"]
	}});
	L.icon = function (options) {
		return new L.Icon(options)
	};
	L.Icon.Default = L.Icon.extend({options: {iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]}, _getIconUrl: function (name) {
		var key = name + "Url";
		if (this.options[key]) {
			return this.options[key]
		}
		var path = L.Icon.Default.imagePath;
		if (!path) {
			throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.")
		}
		return path + "/marker-" + name + (L.Browser.retina && name === "icon" ? "-2x" : "") + ".png"
	}});
	L.Icon.Default.imagePath = function () {
		var scripts = document.getElementsByTagName("script"), leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
		var i, len, src, path;
		for (i = 0, len = scripts.length; i < len; i++) {
			src = scripts[i].src;
			if (src.match(leafletRe)) {
				path = src.split(leafletRe)[0];
				return(path ? path + "/" : "") + "images"
			}
		}
	}();
	L.Marker = L.Layer.extend({options: {pane: "markerPane", icon: new L.Icon.Default, clickable: true, keyboard: true, zIndexOffset: 0, opacity: 1, riseOffset: 250}, initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng)
	}, onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
		this._initIcon();
		this.update()
	}, onRemove: function () {
		if (this.dragging) {
			this.dragging.disable()
		}
		this._removeIcon();
		this._removeShadow()
	}, getEvents: function () {
		var events = {viewreset: this.update};
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom
		}
		return events
	}, getLatLng: function () {
		return this._latlng
	}, setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.update();
		return this.fire("move", {latlng: this._latlng})
	}, setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update()
	}, setIcon: function (icon) {
		this.options.icon = icon;
		if (this._map) {
			this._initIcon();
			this.update()
		}
		if (this._popup) {
			this.bindPopup(this._popup)
		}
		return this
	}, update: function () {
		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos)
		}
		return this
	}, _initIcon: function () {
		var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
		var icon = options.icon.createIcon(this._icon), addIcon = false;
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon()
			}
			addIcon = true;
			if (options.title) {
				icon.title = options.title
			}
			if (options.alt) {
				icon.alt = options.alt
			}
		}
		L.DomUtil.addClass(icon, classToAdd);
		if (options.keyboard) {
			icon.tabIndex = "0"
		}
		this._icon = icon;
		this._initInteraction();
		if (options.riseOnHover) {
			L.DomEvent.on(icon, {mouseover: this._bringToFront, mouseout: this._resetZIndex}, this)
		}
		var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true
		}
		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd)
		}
		this._shadow = newShadow;
		if (options.opacity < 1) {
			this._updateOpacity()
		}
		if (addIcon) {
			this.getPane().appendChild(this._icon)
		}
		if (newShadow && addShadow) {
			this.getPane("shadowPane").appendChild(this._shadow)
		}
	}, _removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent.off(this._icon, {mouseover: this._bringToFront, mouseout: this._resetZIndex}, this)
		}
		L.DomUtil.remove(this._icon);
		this._icon = null
	}, _removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow)
		}
		this._shadow = null
	}, _setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);
		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos)
		}
		this._zIndex = pos.y + this.options.zIndexOffset;
		this._resetZIndex()
	}, _updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset
	}, _animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
		this._setPos(pos)
	}, _initInteraction: function () {
		if (!this.options.clickable) {
			return
		}
		L.DomUtil.addClass(this._icon, "leaflet-clickable");
		L.DomEvent.on(this._icon, "click dblclick mousedown mouseup mouseover mouseout contextmenu keypress", this._fireMouseEvent, this);
		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);
			if (this.options.draggable) {
				this.dragging.enable()
			}
		}
	}, _fireMouseEvent: function (e, type) {
		if (e.type === "mousedown") {
			L.DomEvent.preventDefault(e)
		}
		if (e.type === "click" && this.dragging && this.dragging.moved()) {
			return
		}
		if (e.type === "keypress" && e.keyCode === 13) {
			type = "click"
		}
		this._map._fireMouseEvent(this, e, type, true, this._latlng)
	}, setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity()
		}
		return this
	}, _updateOpacity: function () {
		var opacity = this.options.opacity;
		L.DomUtil.setOpacity(this._icon, opacity);
		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity)
		}
	}, _bringToFront: function () {
		this._updateZIndex(this.options.riseOffset)
	}, _resetZIndex: function () {
		this._updateZIndex(0)
	}});
	L.marker = function (latlng, options) {
		return new L.Marker(latlng, options)
	};
	L.DivIcon = L.Icon.extend({options: {iconSize: [12, 12], className: "leaflet-div-icon", html: false}, createIcon: function (oldIcon) {
		var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
		div.innerHTML = options.html !== false ? options.html : "";
		if (options.bgPos) {
			div.style.backgroundPosition = -options.bgPos.x + "px " + -options.bgPos.y + "px"
		}
		this._setIconStyles(div, "icon");
		return div
	}, createShadow: function () {
		return null
	}});
	L.divIcon = function (options) {
		return new L.DivIcon(options)
	};
	L.Map.mergeOptions({closePopupOnClick: true});
	L.Popup = L.Layer.extend({options: {pane: "popupPane", minWidth: 50, maxWidth: 300, offset: [0, 7], autoPan: true, autoPanPadding: [5, 5], closeButton: true, zoomAnimation: true}, initialize: function (options, source) {
		L.setOptions(this, options);
		this._source = source
	}, onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;
		if (!this._container) {
			this._initLayout()
		}
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0)
		}
		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1)
		}
		map.fire("popupopen", {popup: this});
		if (this._source) {
			this._source.fire("popupopen", {popup: this}, true)
		}
	}, openOn: function (map) {
		map.openPopup(this);
		return this
	}, onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200)
		} else {
			L.DomUtil.remove(this._container)
		}
		map.fire("popupclose", {popup: this});
		if (this._source) {
			this._source.fire("popupclose", {popup: this}, true)
		}
	}, getLatLng: function () {
		return this._latlng
	}, setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan()
		}
		return this
	}, getContent: function () {
		return this._content
	}, setContent: function (content) {
		this._content = content;
		this.update();
		return this
	}, update: function () {
		if (!this._map) {
			return
		}
		this._container.style.visibility = "hidden";
		this._updateContent();
		this._updateLayout();
		this._updatePosition();
		this._container.style.visibility = "";
		this._adjustPan()
	}, getEvents: function () {
		var events = {viewreset: this._updatePosition}, options = this.options;
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom
		}
		if ("closeOnClick"in options ? options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close
		}
		if (options.keepInView) {
			events.moveend = this._adjustPan
		}
		return events
	}, _close: function () {
		if (this._map) {
			this._map.closePopup(this)
		}
	}, _initLayout: function () {
		var prefix = "leaflet-popup", container = this._container = L.DomUtil.create("div", prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"));
		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create("a", prefix + "-close-button", container);
			closeButton.href = "#close";
			closeButton.innerHTML = "&#215;";
			L.DomEvent.on(closeButton, "click", this._onCloseButtonClick, this)
		}
		var wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper", container);
		this._contentNode = L.DomUtil.create("div", prefix + "-content", wrapper);
		L.DomEvent.disableClickPropagation(wrapper).disableScrollPropagation(this._contentNode).on(wrapper, "contextmenu", L.DomEvent.stopPropagation);
		this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container", container);
		this._tip = L.DomUtil.create("div", prefix + "-tip", this._tipContainer)
	}, _updateContent: function () {
		if (!this._content) {
			return
		}
		var node = this._contentNode;
		if (typeof this._content === "string") {
			node.innerHTML = this._content
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild)
			}
			node.appendChild(this._content)
		}
		this.fire("contentupdate")
	}, _updateLayout: function () {
		var container = this._contentNode, style = container.style;
		style.width = "";
		style.whiteSpace = "nowrap";
		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);
		style.width = width + 1 + "px";
		style.whiteSpace = "";
		style.height = "";
		var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + "px";
			L.DomUtil.addClass(container, scrolledClass)
		} else {
			L.DomUtil.removeClass(container, scrolledClass)
		}
		this._containerWidth = this._container.offsetWidth
	}, _updatePosition: function () {
		if (!this._map) {
			return
		}
		var pos = this._map.latLngToLayerPoint(this._latlng), offset = L.point(this.options.offset);
		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos)
		} else {
			offset = offset.add(pos)
		}
		var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
		this._container.style.bottom = bottom + "px";
		this._container.style.left = left + "px"
	}, _animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		L.DomUtil.setPosition(this._container, pos)
	}, _adjustPan: function () {
		if (!this.options.autoPan) {
			return
		}
		var map = this._map, containerHeight = this._container.offsetHeight, containerWidth = this._containerWidth, layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);
		if (this._zoomAnimated) {
			layerPos._add(L.DomUtil.getPosition(this._container))
		}
		var containerPos = map.layerPointToContainerPoint(layerPos), padding = L.point(this.options.autoPanPadding), paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding), paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
		if (containerPos.x + containerWidth + paddingBR.x > size.x) {
			dx = containerPos.x + containerWidth - size.x + paddingBR.x
		}
		if (containerPos.x - dx - paddingTL.x < 0) {
			dx = containerPos.x - paddingTL.x
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) {
			dy = containerPos.y + containerHeight - size.y + paddingBR.y
		}
		if (containerPos.y - dy - paddingTL.y < 0) {
			dy = containerPos.y - paddingTL.y
		}
		if (dx || dy) {
			map.fire("autopanstart").panBy([dx, dy])
		}
	}, _onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e)
	}});
	L.popup = function (options, source) {
		return new L.Popup(options, source)
	};
	L.Map.include({openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			var content = popup;
			popup = new L.Popup(options).setContent(content)
		}
		if (latlng) {
			popup.setLatLng(latlng)
		}
		if (this.hasLayer(popup)) {
			return this
		}
		this.closePopup();
		this._popup = popup;
		return this.addLayer(popup)
	}, closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null
		}
		if (popup) {
			this.removeLayer(popup)
		}
		return this
	}});
	L.Layer.include({bindPopup: function (content, options) {
		if (content instanceof L.Popup) {
			this._popup = content;
			content._source = this
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this)
			}
			this._popup.setContent(content)
		}
		if (!this._popupHandlersAdded) {
			this.on({click: this._openPopup, remove: this.closePopup, move: this._movePopup});
			this._popupHandlersAdded = true
		}
		return this
	}, unbindPopup: function () {
		if (this._popup) {
			this.on({click: this._openPopup, remove: this.closePopup, move: this._movePopup});
			this._popupHandlersAdded = false;
			this._popup = null
		}
		return this
	}, openPopup: function (latlng) {
		if (this._popup && this._map) {
			this._map.openPopup(this._popup, latlng || this._latlng || this.getCenter())
		}
		return this
	}, closePopup: function () {
		if (this._popup) {
			this._popup._close()
		}
		return this
	}, togglePopup: function () {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup()
			} else {
				this.openPopup()
			}
		}
		return this
	}, setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content)
		}
		return this
	}, getPopup: function () {
		return this._popup
	}, _openPopup: function (e) {
		this._map.openPopup(this._popup, e.latlng)
	}, _movePopup: function (e) {
		this._popup.setLatLng(e.latlng)
	}});
	L.Marker.include({bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]).add(L.Popup.prototype.options.offset);
		options = L.extend({offset: anchor}, options);
		return L.Layer.prototype.bindPopup.call(this, content, options)
	}, _openPopup: L.Layer.prototype.togglePopup});
	L.LayerGroup = L.Layer.extend({initialize: function (layers) {
		this._layers = {};
		var i, len;
		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i])
			}
		}
	}, addLayer: function (layer) {
		var id = this.getLayerId(layer);
		this._layers[id] = layer;
		if (this._map) {
			this._map.addLayer(layer)
		}
		return this
	}, removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);
		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id])
		}
		delete this._layers[id];
		return this
	}, hasLayer: function (layer) {
		return!!layer && (layer in this._layers || this.getLayerId(layer)in this._layers)
	}, clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i])
		}
		return this
	}, invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1), i, layer;
		for (i in this._layers) {
			layer = this._layers[i];
			if (layer[methodName]) {
				layer[methodName].apply(layer, args)
			}
		}
		return this
	}, onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i])
		}
	}, onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i])
		}
	}, eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i])
		}
		return this
	}, getLayer: function (id) {
		return this._layers[id]
	}, getLayers: function () {
		var layers = [];
		for (var i in this._layers) {
			layers.push(this._layers[i])
		}
		return layers
	}, setZIndex: function (zIndex) {
		return this.invoke("setZIndex", zIndex)
	}, getLayerId: function (layer) {
		return L.stamp(layer)
	}});
	L.layerGroup = function (layers) {
		return new L.LayerGroup(layers)
	};
	L.FeatureGroup = L.LayerGroup.extend({addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this
		}
		layer.addEventParent(this);
		L.LayerGroup.prototype.addLayer.call(this, layer);
		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions)
		}
		return this.fire("layeradd", {layer: layer})
	}, removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this
		}
		if (layer in this._layers) {
			layer = this._layers[layer]
		}
		layer.removeEventParent(this);
		L.LayerGroup.prototype.removeLayer.call(this, layer);
		if (this._popupContent) {
			this.invoke("unbindPopup")
		}
		return this.fire("layerremove", {layer: layer})
	}, bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke("bindPopup", content, options)
	}, openPopup: function (latlng) {
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break
		}
		return this
	}, setStyle: function (style) {
		return this.invoke("setStyle", style)
	}, bringToFront: function () {
		return this.invoke("bringToFront")
	}, bringToBack: function () {
		return this.invoke("bringToBack")
	}, getBounds: function () {
		var bounds = new L.LatLngBounds;
		this.eachLayer(function (layer) {
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng())
		});
		return bounds
	}});
	L.featureGroup = function (layers) {
		return new L.FeatureGroup(layers)
	};
	L.Renderer = L.Layer.extend({options: {padding: 0}, initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this)
	}, onAdd: function () {
		if (!this._container) {
			this._initContainer();
			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, "leaflet-zoom-animated")
			}
		}
		this.getPane().appendChild(this._container);
		this._update()
	}, onRemove: function () {
		L.DomUtil.remove(this._container)
	}, getEvents: function () {
		var events = {moveend: this._update};
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom
		}
		return events
	}, _animateZoom: function (e) {
		var origin = e.origin.subtract(this._map._getCenterLayerPoint()), offset = this._bounds.min.add(origin.multiplyBy(1 - e.scale)).add(e.offset).round();
		L.DomUtil.setTransform(this._container, offset, e.scale)
	}, _update: function () {
		var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round())
	}});
	L.Map.include({getRenderer: function (layer) {
		var renderer = layer.options.renderer || this.options.renderer || L.SVG && L.SVG.instance || L.Canvas && L.Canvas.instance;
		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer)
		}
		return renderer
	}});
	L.Path = L.Layer.extend({options: {stroke: true, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", fillOpacity: .2, clickable: true}, onAdd: function () {
		this._renderer = this._map.getRenderer(this);
		this._renderer._initPath(this);
		this._project();
		this._update();
		this._renderer._addPath(this)
	}, onRemove: function () {
		this._renderer._removePath(this)
	}, getEvents: function () {
		return{viewreset: this._project, moveend: this._update}
	}, redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this)
		}
		return this
	}, setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this)
		}
		return this
	}, bringToFront: function () {
		this._renderer._bringToFront(this);
		return this
	}, bringToBack: function () {
		this._renderer._bringToBack(this);
		return this
	}, _fireMouseEvent: function (e, type) {
		this._map._fireMouseEvent(this, e, type, true)
	}, _clickTolerance: function () {
		return(this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0)
	}});
	L.LineUtil = {simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice()
		}
		var sqTolerance = tolerance * tolerance;
		points = this._reducePoints(points, sqTolerance);
		points = this._simplifyDP(points, sqTolerance);
		return points
	}, pointToSegmentDistance: function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true))
	}, closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2)
	}, _simplifyDP: function (points, sqTolerance) {
		var len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
		markers[0] = markers[len - 1] = 1;
		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
		var i, newPoints = [];
		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i])
			}
		}
		return newPoints
	}, _simplifyDPStep: function (points, markers, sqTolerance, first, last) {
		var maxSqDist = 0, index, i, sqDist;
		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);
			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist
			}
		}
		if (maxSqDist > sqTolerance) {
			markers[index] = 1;
			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last)
		}
	}, _reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];
		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1])
		}
		return reducedPoints
	}, clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds), codeB = this._getBitCode(b, bounds), codeOut, p, newCode;
		this._lastCode = codeB;
		while (true) {
			if (!(codeA | codeB)) {
				return[a, b]
			} else if (codeA & codeB) {
				return false
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);
				if (codeOut === codeA) {
					a = p;
					codeA = newCode
				} else {
					b = p;
					codeB = newCode
				}
			}
		}
	}, _getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
		if (code & 8) {
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y
		} else if (code & 4) {
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y
		} else if (code & 2) {
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx
		} else if (code & 1) {
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx
		}
		return new L.Point(x, y, true)
	}, _getBitCode: function (p, bounds) {
		var code = 0;
		if (p.x < bounds.min.x) {
			code |= 1
		} else if (p.x > bounds.max.x) {
			code |= 2
		}
		if (p.y < bounds.min.y) {
			code |= 4
		} else if (p.y > bounds.max.y) {
			code |= 8
		}
		return code
	}, _sqDist: function (p1, p2) {
		var dx = p2.x - p1.x, dy = p2.y - p1.y;
		return dx * dx + dy * dy
	}, _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
			if (t > 1) {
				x = p2.x;
				y = p2.y
			} else if (t > 0) {
				x += dx * t;
				y += dy * t
			}
		}
		dx = p.x - x;
		dy = p.y - y;
		return sqDist ? dx * dx + dy * dy : new L.Point(x, y)
	}};
	L.Polyline = L.Path.extend({options: {smoothFactor: 1}, initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs)
	}, getLatLngs: function () {
		return this._latlngs
	}, setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw()
	}, addLatLng: function (latlng) {
		latlng = L.latLng(latlng);
		this._latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw()
	}, spliceLatLngs: function () {
		var removed = [].splice.apply(this._latlngs, arguments);
		this._setLatLngs(this._latlngs);
		this.redraw();
		return removed
	}, closestLayerPoint: function (p) {
		var minDistance = Infinity, minPoint = null, closest = L.LineUtil._sqClosestPointOnSegment, p1, p2;
		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];
			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];
				var sqDist = closest(p, p1, p2, true);
				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2)
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance)
		}
		return minPoint
	}, getCenter: function () {
		var i, halfDist, segDist, dist, p1, p2, ratio, points = this._rings[0], len = points.length;
		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2
		}
		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;
			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)])
			}
		}
	}, getBounds: function () {
		return this._bounds
	}, _setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds;
		this._latlngs = this._convertLatLngs(latlngs)
	}, _convertLatLngs: function (latlngs) {
		var result = [], flat = this._flat(latlngs);
		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i])
			} else {
				result[i] = this._convertLatLngs(latlngs[i])
			}
		}
		return result
	}, _flat: function (latlngs) {
		return!L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== "object"
	}, _project: function () {
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings);
		var w = this._clickTolerance(), p = new L.Point(w, -w);
		if (this._latlngs.length) {
			this._pxBounds = new L.Bounds(this._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(p), this._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(p))
		}
	}, _projectLatlngs: function (latlngs, result) {
		var flat = latlngs[0]instanceof L.LatLng, len = latlngs.length, i, ring;
		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i])
			}
			result.push(ring)
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result)
			}
		}
	}, _clipPoints: function () {
		if (this.options.noClip) {
			this._parts = this._rings;
			return
		}
		this._parts = [];
		var parts = this._parts, bounds = this._renderer._bounds, i, j, k, len, len2, segment, points;
		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];
			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j);
				if (!segment) {
					continue
				}
				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);
				if (segment[1] !== points[j + 1] || j === len2 - 2) {
					parts[k].push(segment[1]);
					k++
				}
			}
		}
	}, _simplifyPoints: function () {
		var parts = this._parts, tolerance = this.options.smoothFactor;
		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance)
		}
	}, _update: function () {
		if (!this._map) {
			return
		}
		this._clipPoints();
		this._simplifyPoints();
		this._updatePath()
	}, _updatePath: function () {
		this._renderer._updatePoly(this)
	}});
	L.polyline = function (latlngs, options) {
		return new L.Polyline(latlngs, options)
	};
	L.PolyUtil = {};
	L.PolyUtil.clipPolygon = function (points, bounds) {
		var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge, p, lu = L.LineUtil;
		for (i = 0, len = points.length; i < len; i++) {
			points[i]._code = lu._getBitCode(points[i], bounds)
		}
		for (k = 0; k < 4; k++) {
			edge = edges[k];
			clippedPoints = [];
			for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
				a = points[i];
				b = points[j];
				if (!(a._code & edge)) {
					if (b._code & edge) {
						p = lu._getEdgeIntersection(b, a, edge, bounds);
						p._code = lu._getBitCode(p, bounds);
						clippedPoints.push(p)
					}
					clippedPoints.push(a)
				} else if (!(b._code & edge)) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p)
				}
			}
			points = clippedPoints
		}
		return points
	};
	L.Polygon = L.Polyline.extend({options: {fill: true}, getCenter: function () {
		var i, j, len, p1, p2, f, area, x, y, points = this._rings[0];
		area = x = y = 0;
		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];
			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3
		}
		return this._map.layerPointToLatLng([x / area, y / area])
	}, _convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
		if (len >= 2 && result[0]instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop()
		}
		return result
	}, _clipPoints: function () {
		if (this.options.noClip) {
			this._parts = this._rings;
			return
		}
		var bounds = this._renderer._bounds, w = this.options.weight, p = new L.Point(w, w);
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));
		this._parts = [];
		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds);
			if (clipped.length) {
				this._parts.push(clipped)
			}
		}
	}, _updatePath: function () {
		this._renderer._updatePoly(this, true)
	}});
	L.polygon = function (latlngs, options) {
		return new L.Polygon(latlngs, options)
	};
	L.Rectangle = L.Polygon.extend({initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options)
	}, setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds))
	}, _boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return[latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()]
	}});
	L.rectangle = function (latLngBounds, options) {
		return new L.Rectangle(latLngBounds, options)
	};
	L.CircleMarker = L.Path.extend({options: {fill: true, radius: 10}, initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius
	}, setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire("move", {latlng: this._latlng})
	}, getLatLng: function () {
		return this._latlng
	}, setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw()
	}, getRadius: function () {
		return this._radius
	}, setStyle: function (options) {
		this._radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options)
	}, _project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds()
	}, _updateBounds: function () {
		var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p))
	}, _update: function () {
		if (this._map) {
			this._updatePath()
		}
	}, _updatePath: function () {
		this._renderer._updateCircle(this)
	}, _empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
	}});
	L.circleMarker = function (latlng, options) {
		return new L.CircleMarker(latlng, options)
	};
	L.Circle = L.CircleMarker.extend({initialize: function (latlng, radius, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._mRadius = radius
	}, setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw()
	}, getRadius: function () {
		return this._mRadius
	}, getBounds: function () {
		var half = [this._radius, this._radiusY];
		return new L.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)))
	}, setStyle: L.Path.prototype.setStyle, _project: function () {
		var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180, latR = this._mRadius / L.CRS.Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1)
		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x
		}
		this._updateBounds()
	}});
	L.circle = function (latlng, radius, options) {
		return new L.Circle(latlng, radius, options)
	};
	L.SVG = L.Renderer.extend({_initContainer: function () {
		this._container = L.SVG.create("svg");
		this._paths = {};
		this._initEvents();
		this._container.setAttribute("pointer-events", "none")
	}, _update: function () {
		if (this._map._animatingZoom) {
			return
		}
		L.Renderer.prototype._update.call(this);
		var b = this._bounds, size = b.getSize(), container = this._container, pane = this.getPane();
		if (L.Browser.mobileWebkit) {
			pane.removeChild(container)
		}
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute("width", size.x);
		container.setAttribute("height", size.y);
		container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
		if (L.Browser.mobileWebkit) {
			pane.appendChild(container)
		}
	}, _initPath: function (layer) {
		var path = layer._path = L.SVG.create("path");
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className)
		}
		if (layer.options.clickable) {
			L.DomUtil.addClass(path, "leaflet-clickable")
		}
		this._updateStyle(layer)
	}, _addPath: function (layer) {
		var path = layer._path;
		this._container.appendChild(path);
		this._paths[L.stamp(path)] = layer
	}, _removePath: function (layer) {
		var path = layer._path;
		L.DomUtil.remove(path);
		delete this._paths[L.stamp(path)]
	}, _updatePath: function (layer) {
		layer._project();
		layer._update()
	}, _updateStyle: function (layer) {
		var path = layer._path, options = layer.options;
		if (!path) {
			return
		}
		if (options.stroke) {
			path.setAttribute("stroke", options.color);
			path.setAttribute("stroke-opacity", options.opacity);
			path.setAttribute("stroke-width", options.weight);
			path.setAttribute("stroke-linecap", options.lineCap);
			path.setAttribute("stroke-linejoin", options.lineJoin);
			if (options.dashArray) {
				path.setAttribute("stroke-dasharray", options.dashArray)
			} else {
				path.removeAttribute("stroke-dasharray")
			}
		} else {
			path.setAttribute("stroke", "none")
		}
		if (options.fill) {
			path.setAttribute("fill", options.fillColor || options.color);
			path.setAttribute("fill-opacity", options.fillOpacity);
			path.setAttribute("fill-rule", "evenodd")
		} else {
			path.setAttribute("fill", "none")
		}
		path.setAttribute("pointer-events", options.pointerEvents || (options.clickable ? "auto" : "none"))
	}, _updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed))
	}, _updateCircle: function (layer) {
		var p = layer._point, r = layer._radius, r2 = layer._radiusY || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
		var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
		this._setPath(layer, d)
	}, _setPath: function (layer, path) {
		layer._path.setAttribute("d", path)
	}, _bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path)
	}, _bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path)
	}, _initEvents: function () {
		L.DomEvent.on(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu", this._fireMouseEvent, this)
	}, _fireMouseEvent: function (e) {
		this._paths[L.stamp(e.target)]._fireMouseEvent(e)
	}});
	L.extend(L.SVG, {create: function (name) {
		return document.createElementNS("http://www.w3.org/2000/svg", name)
	}, pointsToPath: function (rings, closed) {
		var str = "", i, j, len, len2, points, p;
		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];
			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? "L" : "M") + p.x + " " + p.y
			}
			str += closed ? L.Browser.svg ? "z" : "x" : ""
		}
		return str || "M0 0"
	}});
	L.Browser.svg = !!(document.createElementNS && L.SVG.create("svg").createSVGRect);
	L.svg = function (options) {
		return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null
	};
	L.SVG.instance = L.svg();
	L.Browser.vml = !L.Browser.svg && function () {
		try {
			var div = document.createElement("div");
			div.innerHTML = '<v:shape adj="1"/>';
			var shape = div.firstChild;
			shape.style.behavior = "url(#default#VML)";
			return shape && typeof shape.adj === "object"
		} catch (e) {
			return false
		}
	}();
	L.SVG.include(!L.Browser.vml ? {} : {_initContainer: function () {
		this._container = L.DomUtil.create("div", "leaflet-vml-container")
	}, _update: function () {
		if (this._map._animatingZoom) {
			return
		}
		L.Renderer.prototype._update.call(this)
	}, _initPath: function (layer) {
		var container = layer._container = L.SVG.create("shape");
		L.DomUtil.addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
		container.coordsize = "1 1";
		layer._path = L.SVG.create("path");
		container.appendChild(layer._path);
		if (layer.options.clickable) {
			this._initEvents(layer, container)
		}
		this._updateStyle(layer)
	}, _addPath: function (layer) {
		this._container.appendChild(layer._container)
	}, _removePath: function (layer) {
		L.DomUtil.remove(layer._container)
	}, _updateStyle: function (layer) {
		var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
		container.stroked = !!options.stroke;
		container.filled = !!options.fill;
		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create("stroke");
				container.appendChild(stroke)
			}
			stroke.weight = options.weight + "px";
			stroke.color = options.color;
			stroke.opacity = options.opacity;
			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ")
			} else {
				stroke.dashStyle = ""
			}
			stroke.endcap = options.lineCap.replace("butt", "flat");
			stroke.joinstyle = options.lineJoin
		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null
		}
		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create("fill");
				container.appendChild(fill)
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity
		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null
		}
	}, _updateCircle: function (layer) {
		var p = layer._point, r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
		this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360)
	}, _setPath: function (layer, path) {
		layer._path.v = path
	}});
	if (L.Browser.vml) {
		L.SVG.create = function () {
			try {
				document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
				return function (name) {
					return document.createElement("<lvml:" + name + ' class="lvml">')
				}
			} catch (e) {
				return function (name) {
					return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
				}
			}
		}();
		L.SVG.instance = L.svg()
	}
	L.Canvas = L.Renderer.extend({onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);
		this._layers = this._layers || {};
		this._draw()
	}, _initContainer: function () {
		var container = this._container = document.createElement("canvas");
		L.DomEvent.on(container, "mousemove", this._onMouseMove, this).on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
		this._ctx = container.getContext("2d")
	}, _update: function () {
		if (this._map._animatingZoom) {
			return
		}
		L.Renderer.prototype._update.call(this);
		var b = this._bounds, container = this._container, size = b.getSize(), m = L.Browser.retina ? 2 : 1;
		L.DomUtil.setPosition(container, b.min);
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + "px";
		container.style.height = size.y + "px";
		if (L.Browser.retina) {
			this._ctx.scale(2, 2)
		}
		this._ctx.translate(-b.min.x, -b.min.y)
	}, _initPath: function (layer) {
		this._layers[L.stamp(layer)] = layer
	}, _addPath: L.Util.falseFn, _removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer)
	}, _updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		this._draw();
		this._redrawBounds = null
	}, _updateStyle: function (layer) {
		this._requestRedraw(layer)
	}, _requestRedraw: function (layer) {
		if (!this._map) {
			return
		}
		this._redrawBounds = this._redrawBounds || new L.Bounds;
		this._redrawBounds.extend(layer._pxBounds.min).extend(layer._pxBounds.max);
		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this)
	}, _redraw: function () {
		this._redrawRequest = null;
		this._draw(true);
		this._draw();
		this._redrawBounds = null
	}, _draw: function (clear) {
		this._clear = clear;
		var layer;
		for (var id in this._layers) {
			layer = this._layers[id];
			if (!this._redrawBounds || layer._pxBounds.intersects(this._redrawBounds)) {
				layer._updatePath()
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id]
			}
		}
	}, _updatePoly: function (layer, closed) {
		var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
		if (!len) {
			return
		}
		ctx.beginPath();
		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? "lineTo" : "moveTo"](p.x, p.y)
			}
			if (closed) {
				ctx.closePath()
			}
		}
		this._fillStroke(ctx, layer)
	}, _updateCircle: function (layer) {
		if (layer._empty()) {
			return
		}
		var p = layer._point, ctx = this._ctx, r = layer._radius, s = (layer._radiusY || r) / r;
		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s)
		}
		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
		if (s !== 1) {
			ctx.restore()
		}
		this._fillStroke(ctx, layer)
	}, _fillStroke: function (ctx, layer) {
		var clear = this._clear, options = layer.options;
		ctx.globalCompositeOperation = clear ? "destination-out" : "source-over";
		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill("evenodd")
		}
		if (options.stroke) {
			ctx.globalAlpha = clear ? 1 : options.opacity;
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke()
		}
	}, _onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e);
		for (var id in this._layers) {
			if (this._layers[id]._containsPoint(point)) {
				this._layers[id]._fireMouseEvent(e)
			}
		}
	}, _onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) {
			return
		}
		var point = this._map.mouseEventToLayerPoint(e);
		for (var id in this._layers) {
			this._handleHover(this._layers[id], e, point)
		}
	}, _handleHover: function (layer, e, point) {
		if (!layer.options.clickable) {
			return
		}
		if (layer._containsPoint(point)) {
			if (!layer._mouseInside) {
				L.DomUtil.addClass(this._container, "leaflet-clickable");
				layer._fireMouseEvent(e, "mouseover");
				layer._mouseInside = true
			}
			layer._fireMouseEvent(e)
		} else if (layer._mouseInside) {
			L.DomUtil.removeClass(this._container, "leaflet-clickable");
			layer._fireMouseEvent(e, "mouseout");
			layer._mouseInside = false
		}
	}, _bringToFront: L.Util.falseFn, _bringToBack: L.Util.falseFn});
	L.Browser.canvas = function () {
		return!!document.createElement("canvas").getContext
	}();
	L.canvas = function (options) {
		return L.Browser.canvas ? new L.Canvas(options) : null
	};
	L.Canvas.instance = L.canvas();
	L.Polyline.prototype._containsPoint = function (p, closed) {
		var i, j, k, len, len2, part, w = this._clickTolerance();
		if (!this._pxBounds.contains(p)) {
			return false
		}
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && j === 0) {
					continue
				}
				if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true
				}
			}
		}
		return false
	};
	L.Polygon.prototype._containsPoint = function (p) {
		var inside = false, part, p1, p2, i, j, k, len, len2;
		if (!this._pxBounds.contains(p)) {
			return false
		}
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];
				if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
					inside = !inside
				}
			}
		}
		return inside || L.Polyline.prototype._containsPoint.call(this, p, true)
	};
	L.Circle.prototype._containsPoint = function (p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance()
	};
	L.GeoJSON = L.FeatureGroup.extend({initialize: function (geojson, options) {
		L.setOptions(this, options);
		this._layers = {};
		if (geojson) {
			this.addData(geojson)
		}
	}, addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features, i, len, feature;
		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature)
				}
			}
			return this
		}
		var options = this.options;
		if (options.filter && !options.filter(geojson)) {
			return
		}
		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		layer.feature = L.GeoJSON.asFeature(geojson);
		layer.defaultOptions = layer.options;
		this.resetStyle(layer);
		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer)
		}
		return this.addLayer(layer)
	}, resetStyle: function (layer) {
		layer.options = layer.defaultOptions;
		this._setLayerStyle(layer, this.options.style)
	}, setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style)
		}, this)
	}, _setLayerStyle: function (layer, style) {
		if (typeof style === "function") {
			style = style(layer.feature)
		}
		if (layer.setStyle) {
			layer.setStyle(style)
		}
	}});
	L.extend(L.GeoJSON, {geometryToLayer: function (geojson, options) {
		var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry.coordinates, layers = [], coordsToLatLng = options.coordsToLatLng || this.coordsToLatLng, latlng, latlngs, i, len;
		switch (geometry.type) {
			case"Point":
				latlng = coordsToLatLng(coords);
				return options.pointToLayer ? options.pointToLayer(geojson, latlng) : new L.Marker(latlng);
			case"MultiPoint":
				for (i = 0, len = coords.length; i < len; i++) {
					latlng = coordsToLatLng(coords[i]);
					layers.push(options.pointToLayer ? options.pointToLayer(geojson, latlng) : new L.Marker(latlng))
				}
				return new L.FeatureGroup(layers);
			case"LineString":
			case"MultiLineString":
				latlngs = this.coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, coordsToLatLng);
				return new L.Polyline(latlngs, options);
			case"Polygon":
			case"MultiPolygon":
				latlngs = this.coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, coordsToLatLng);
				return new L.Polygon(latlngs, options);
			case"GeometryCollection":
				for (i = 0, len = geometry.geometries.length; i < len; i++) {
					layers.push(this.geometryToLayer({geometry: geometry.geometries[i], type: "Feature", properties: geojson.properties}, options))
				}
				return new L.FeatureGroup(layers);
			default:
				throw new Error("Invalid GeoJSON object.")
		}
	}, coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2])
	}, coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];
		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ? this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) : coordsToLatLng(coords[i]);
			latlngs.push(latlng)
		}
		return latlngs
	}, latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ? [latlng.lng, latlng.lat, latlng.alt] : [latlng.lng, latlng.lat]
	}, latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];
		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ? L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) : L.GeoJSON.latLngToCoords(latlngs[i]))
		}
		if (!levelsDeep && closed) {
			coords.push(coords[0])
		}
		return coords
	}, getFeature: function (layer, newGeometry) {
		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry)
	}, asFeature: function (geoJSON) {
		if (geoJSON.type === "Feature") {
			return geoJSON
		}
		return{type: "Feature", properties: {}, geometry: geoJSON}
	}});
	var PointToGeoJSON = {toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {type: "Point", coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())})
	}};
	L.Marker.include(PointToGeoJSON);
	L.Circle.include(PointToGeoJSON);
	L.CircleMarker.include(PointToGeoJSON);
	L.Polyline.prototype.toGeoJSON = function () {
		var multi = !this._flat(this._latlngs);
		var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);
		return L.GeoJSON.getFeature(this, {type: (multi ? "Multi" : "") + "LineString", coordinates: coords})
	};
	L.Polygon.prototype.toGeoJSON = function () {
		var holes = !this._flat(this._latlngs), multi = holes && !this._flat(this._latlngs[0]);
		var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);
		if (holes && this._latlngs.length === 1) {
			multi = true;
			coords = [coords]
		}
		if (!holes) {
			coords = [coords]
		}
		return L.GeoJSON.getFeature(this, {type: (multi ? "Multi" : "") + "Polygon", coordinates: coords})
	};
	L.LayerGroup.include({toMultiPoint: function () {
		var coords = [];
		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates)
		});
		return L.GeoJSON.getFeature(this, {type: "MultiPoint", coordinates: coords})
	}, toGeoJSON: function () {
		var type = this.feature && this.feature.geometry && this.feature.geometry.type;
		if (type === "MultiPoint") {
			return this.toMultiPoint()
		}
		var isGeometryCollection = type === "GeometryCollection", jsons = [];
		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json))
			}
		});
		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {geometries: jsons, type: "GeometryCollection"})
		}
		return{type: "FeatureCollection", features: jsons}
	}});
	L.geoJson = function (geojson, options) {
		return new L.GeoJSON(geojson, options)
	};
	var eventsKey = "_leaflet_events";
	L.DomEvent = {on: function (obj, types, fn, context) {
		if (typeof types === "object") {
			for (var type in types) {
				this._on(obj, type, types[type], fn)
			}
		} else {
			types = L.Util.splitWords(types);
			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context)
			}
		}
		return this
	}, off: function (obj, types, fn, context) {
		if (typeof types === "object") {
			for (var type in types) {
				this._off(obj, type, types[type], fn)
			}
		} else {
			types = L.Util.splitWords(types);
			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context)
			}
		}
		return this
	}, _on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? "_" + L.stamp(context) : "");
		if (obj[eventsKey] && obj[eventsKey][id]) {
			return this
		}
		var handler = function (e) {
			return fn.call(context || obj, e || window.event)
		};
		var originalHandler = handler;
		if (L.Browser.pointer && type.indexOf("touch") === 0) {
			return this.addPointerListener(obj, type, handler, id)
		}
		if (L.Browser.touch && type === "dblclick" && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id)
		}
		if ("addEventListener"in obj) {
			if (type === "mousewheel") {
				obj.addEventListener("DOMMouseScroll", handler, false);
				obj.addEventListener(type, handler, false)
			} else if (type === "mouseenter" || type === "mouseleave") {
				handler = function (e) {
					e = e || window.event;
					if (!L.DomEvent._checkMouse(obj, e)) {
						return
					}
					return originalHandler(e)
				};
				obj.addEventListener(type === "mouseenter" ? "mouseover" : "mouseout", handler, false)
			} else {
				if (type === "click" && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler)
					}
				}
				obj.addEventListener(type, handler, false)
			}
		} else if ("attachEvent"in obj) {
			obj.attachEvent("on" + type, handler)
		}
		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;
		return this
	}, _off: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? "_" + L.stamp(context) : ""), handler = obj[eventsKey] && obj[eventsKey][id];
		if (!handler) {
			return this
		}
		if (L.Browser.pointer && type.indexOf("touch") === 0) {
			this.removePointerListener(obj, type, id)
		} else if (L.Browser.touch && type === "dblclick" && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id)
		} else if ("removeEventListener"in obj) {
			if (type === "mousewheel") {
				obj.removeEventListener("DOMMouseScroll", handler, false);
				obj.removeEventListener(type, handler, false)
			} else {
				obj.removeEventListener(type === "mouseenter" ? "mouseover" : type === "mouseleave" ? "mouseout" : type, handler, false)
			}
		} else if ("detachEvent"in obj) {
			obj.detachEvent("on" + type, handler)
		}
		obj[eventsKey][id] = null;
		return this
	}, stopPropagation: function (e) {
		if (e.stopPropagation) {
			e.stopPropagation()
		} else {
			e.cancelBubble = true
		}
		L.DomEvent._skipped(e);
		return this
	}, disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, "mousewheel MozMousePixelScroll", L.DomEvent.stopPropagation)
	}, disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;
		L.DomEvent.on(el, L.Draggable.START.join(" "), stop);
		return L.DomEvent.on(el, {click: L.DomEvent._fakeStop, dblclick: stop})
	}, preventDefault: function (e) {
		if (e.preventDefault) {
			e.preventDefault()
		} else {
			e.returnValue = false
		}
		return this
	}, stop: function (e) {
		return L.DomEvent.preventDefault(e).stopPropagation(e)
	}, getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX || e.pageX, e.clientY || e.pageY)
		}
		var rect = container.getBoundingClientRect();
		return new L.Point((e.clientX || e.pageX) - rect.left - container.clientLeft, (e.clientY || e.pageY) - rect.top - container.clientTop)
	}, getWheelDelta: function (e) {
		var delta = 0;
		if (e.wheelDelta) {
			delta = e.wheelDelta / 120
		}
		if (e.detail) {
			delta = -e.detail / 3
		}
		return delta
	}, _skipEvents: {}, _fakeStop: function (e) {
		L.DomEvent._skipEvents[e.type] = true
	}, _skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		this._skipEvents[e.type] = false;
		return skipped
	}, _checkMouse: function (el, e) {
		var related = e.relatedTarget;
		if (!related) {
			return true
		}
		try {
			while (related && related !== el) {
				related = related.parentNode
			}
		} catch (err) {
			return false
		}
		return related !== el
	}, _filterClick: function (e, handler) {
		var timeStamp = e.timeStamp || e.originalEvent.timeStamp, elapsed = L.DomEvent._lastClick && timeStamp - L.DomEvent._lastClick;
		if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
			L.DomEvent.stop(e);
			return
		}
		L.DomEvent._lastClick = timeStamp;
		return handler(e)
	}};
	L.DomEvent.addListener = L.DomEvent.on;
	L.DomEvent.removeListener = L.DomEvent.off;
	L.Draggable = L.Evented.extend({statics: {START: L.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"], END: {mousedown: "mouseup", touchstart: "touchend", pointerdown: "touchend", MSPointerDown: "touchend"}, MOVE: {mousedown: "mousemove", touchstart: "touchmove", pointerdown: "touchmove", MSPointerDown: "touchmove"}}, initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element
	}, enable: function () {
		if (this._enabled) {
			return
		}
		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(" "), this._onDown, this);
		this._enabled = true
	}, disable: function () {
		if (!this._enabled) {
			return
		}
		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(" "), this._onDown, this);
		this._enabled = false;
		this._moved = false
	}, _onDown: function (e) {
		this._moved = false;
		if (e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
			return
		}
		L.DomEvent.stopPropagation(e);
		if (L.Draggable._disabled) {
			return
		}
		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();
		if (this._moving) {
			return
		}
		this.fire("down");
		var first = e.touches ? e.touches[0] : e;
		this._startPoint = new L.Point(first.clientX || first.pageX, first.clientY || first.pageY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);
		L.DomEvent.on(document, L.Draggable.MOVE[e.type], this._onMove, this).on(document, L.Draggable.END[e.type], this._onUp, this)
	}, _onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return
		}
		var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, newPoint = new L.Point(first.clientX || first.pageX, first.clientY || first.pageY), offset = newPoint.subtract(this._startPoint);
		if (!offset.x && !offset.y) {
			return
		}
		L.DomEvent.preventDefault(e);
		if (!this._moved) {
			this.fire("dragstart");
			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);
			L.DomUtil.addClass(document.body, "leaflet-dragging");
			L.DomUtil.addClass(e.target || e.srcElement, "leaflet-drag-target")
		}
		this._newPos = this._startPos.add(offset);
		this._moving = true;
		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget)
	}, _updatePosition: function () {
		this.fire("predrag");
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire("drag")
	}, _onUp: function (e) {
		L.DomUtil.removeClass(document.body, "leaflet-dragging");
		L.DomUtil.removeClass(e.target || e.srcElement, "leaflet-drag-target");
		for (var i in L.Draggable.MOVE) {
			L.DomEvent.off(document, L.Draggable.MOVE[i], this._onMove, this).off(document, L.Draggable.END[i], this._onUp, this)
		}
		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();
		if (this._moved && this._moving) {
			L.Util.cancelAnimFrame(this._animRequest);
			this.fire("dragend", {distance: this._newPos.distanceTo(this._startPos)})
		}
		this._moving = false
	}});
	L.Handler = L.Class.extend({initialize: function (map) {
		this._map = map
	}, enable: function () {
		if (this._enabled) {
			return
		}
		this._enabled = true;
		this.addHooks()
	}, disable: function () {
		if (!this._enabled) {
			return
		}
		this._enabled = false;
		this.removeHooks()
	}, enabled: function () {
		return!!this._enabled
	}});
	L.Map.mergeOptions({dragging: true, inertia: !L.Browser.android23, inertiaDeceleration: 3400, inertiaMaxSpeed: Infinity, inertiaThreshold: L.Browser.touch && !window.UsingDesktopTouchscreen ? 32 : 18, easeLinearity: .25, worldCopyJump: false});
	L.Map.Drag = L.Handler.extend({addHooks: function () {
		if (!this._draggable) {
			var map = this._map;
			this._draggable = new L.Draggable(map._mapPane, map._container);
			this._draggable.on({down: this._onDown, dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd}, this);
			if (map.options.worldCopyJump) {
				this._draggable.on("predrag", this._onPreDrag, this);
				map.on("viewreset", this._onViewReset, this);
				map.whenReady(this._onViewReset, this)
			}
		}
		this._draggable.enable()
	}, removeHooks: function () {
		this._draggable.disable()
	}, moved: function () {
		return this._draggable && this._draggable._moved
	}, _onDown: function () {
		if (this._map._panAnim) {
			this._map._panAnim.stop()
		}
	}, _onDragStart: function () {
		var map = this._map;
		map.fire("movestart").fire("dragstart");
		if (map.options.inertia) {
			this._positions = [];
			this._times = []
		}
	}, _onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date, pos = this._lastPos = this._draggable._newPos;
			this._positions.push(pos);
			this._times.push(time);
			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift()
			}
		}
		this._map.fire("move").fire("drag")
	}, _onViewReset: function () {
		var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x
	}, _onPreDrag: function () {
		var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
		this._draggable._newPos.x = newX
	}, _onDragEnd: function (e) {
		var map = this._map, options = map.options, delay = +new Date - this._lastTime, noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];
		map.fire("dragend", e);
		if (noInertia) {
			map.fire("moveend")
		} else {
			var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime + delay - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
			if (!offset.x || !offset.y) {
				map.fire("moveend")
			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);
				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {duration: decelerationDuration, easeLinearity: ease, noMoveStart: true})
				})
			}
		}
	}});
	L.Map.addInitHook("addHandler", "dragging", L.Map.Drag);
	L.Map.mergeOptions({doubleClickZoom: true});
	L.Map.DoubleClickZoom = L.Handler.extend({addHooks: function () {
		this._map.on("dblclick", this._onDoubleClick, this)
	}, removeHooks: function () {
		this._map.off("dblclick", this._onDoubleClick, this)
	}, _onDoubleClick: function (e) {
		var map = this._map, oldZoom = map.getZoom(), zoom = e.originalEvent.shiftKey ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;
		if (map.options.doubleClickZoom === "center") {
			map.setZoom(zoom)
		} else {
			map.setZoomAround(e.containerPoint, zoom)
		}
	}});
	L.Map.addInitHook("addHandler", "doubleClickZoom", L.Map.DoubleClickZoom);
	L.Map.mergeOptions({scrollWheelZoom: true, scrollWheelFractionalZoom: false});
	L.Map.ScrollWheelZoom = L.Handler.extend({addHooks: function () {
		L.DomEvent.on(this._map._container, {mousewheel: this._onWheelScroll, MozMousePixelScroll: L.DomEvent.preventDefault}, this);
		this._delta = 0
	}, removeHooks: function () {
		L.DomEvent.off(this._map._container, {mousewheel: this._onWheelScroll, MozMousePixelScroll: L.DomEvent.preventDefault}, this)
	}, _onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);
		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);
		if (!this._map.options.scrollWheelFractionalZoom) {
			if (!this._startTime) {
				this._startTime = +new Date
			}
			var left = Math.max(40 - (+new Date - this._startTime), 0);
			clearTimeout(this._timer);
			this._timer = setTimeout(L.bind(this._performZoom, this), left);
			L.DomEvent.stop(e)
		} else {
			var map = this._map, zoom = map.getZoom();
			var newZoom = zoom + delta;
			var zoomAround = map.layerPointToLatLng(this._lastMousePos);
			if (map.options.scrollWheelZoom === "center") {
				map.setZoom(newZoom)
			} else {
				var tempZoomSetting = map._zoomAnimated;
				map._zoomAnimated = false;
				map.setZoomAround(this._lastMousePos, newZoom, {reset: true});
				map._zoomAnimated = tempZoomSetting
			}
		}
	}, _performZoom: function () {
		var map = this._map, delta = this._delta, zoom = map.getZoom();
		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;
		this._delta = 0;
		this._startTime = null;
		if (!delta) {
			return
		}
		if (map.options.scrollWheelZoom === "center") {
			map.setZoom(zoom + delta)
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta)
		}
	}});
	L.Map.addInitHook("addHandler", "scrollWheelZoom", L.Map.ScrollWheelZoom);
	L.extend(L.DomEvent, {_touchstart: L.Browser.msPointer ? "MSPointerDown" : L.Browser.pointer ? "pointerdown" : "touchstart", _touchend: L.Browser.msPointer ? "MSPointerUp" : L.Browser.pointer ? "pointerup" : "touchend", addDoubleTapListener: function (obj, handler, id) {
		var last, touch, doubleTap = false, delay = 250, trackedTouches = [];

		function onTouchStart(e) {
			var count;
			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length
			} else {
				count = e.touches.length
			}
			if (count > 1) {
				return
			}
			var now = Date.now(), delta = now - (last || now);
			touch = e.touches ? e.touches[0] : e;
			doubleTap = delta > 0 && delta <= delay;
			last = now
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) {
					return
				}
				trackedTouches.splice(idx, 1)
			}
			if (doubleTap) {
				if (L.Browser.pointer) {
					var newTouch = {}, prop, i;
					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop
					}
					touch = newTouch
				}
				touch.type = "dblclick";
				handler(touch);
				last = null
			}
		}

		var pre = "_leaflet_", touchstart = this._touchstart, touchend = this._touchend;
		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		var endElement = L.Browser.pointer ? document.documentElement : obj;
		obj.addEventListener(touchstart, onTouchStart, false);
		endElement.addEventListener(touchend, onTouchEnd, false);
		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false)
		}
		return this
	}, removeDoubleTapListener: function (obj, id) {
		var pre = "_leaflet_", endElement = L.Browser.pointer ? document.documentElement : obj, touchend = obj[pre + this._touchend + id];
		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		endElement.removeEventListener(this._touchend, touchend, false);
		if (L.Browser.pointer) {
			endElement.removeEventListener(L.DomEvent.POINTER_CANCEL, touchend, false)
		}
		return this
	}});
	L.extend(L.DomEvent, {POINTER_DOWN: L.Browser.msPointer ? "MSPointerDown" : "pointerdown", POINTER_MOVE: L.Browser.msPointer ? "MSPointerMove" : "pointermove", POINTER_UP: L.Browser.msPointer ? "MSPointerUp" : "pointerup", POINTER_CANCEL: L.Browser.msPointer ? "MSPointerCancel" : "pointercancel", _pointers: {}, addPointerListener: function (obj, type, handler, id) {
		if (type === "touchstart") {
			this._addPointerStart(obj, handler, id)
		} else if (type === "touchmove") {
			this._addPointerMove(obj, handler, id)
		} else if (type === "touchend") {
			this._addPointerEnd(obj, handler, id)
		}
		return this
	}, removePointerListener: function (obj, type, id) {
		var handler = obj["_leaflet_" + type + id];
		if (type === "touchstart") {
			obj.removeEventListener(this.POINTER_DOWN, handler, false)
		} else if (type === "touchmove") {
			obj.removeEventListener(this.POINTER_MOVE, handler, false)
		} else if (type === "touchend") {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false)
		}
		return this
	}, _addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			L.DomEvent.preventDefault(e);
			this._pointers[e.pointerId] = e;
			this._handlePointer(e, handler)
		}, this);
		obj["_leaflet_touchstart" + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);
		if (!this._pointerDocListener) {
			var removePointer = L.bind(function (e) {
				delete this._pointers[e.pointerId]
			}, this);
			document.documentElement.addEventListener(this.POINTER_UP, removePointer, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, removePointer, false);
			this._pointerDocListener = true
		}
	}, _handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i])
		}
		e.changedTouches = [e];
		handler(e)
	}, _addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === "mouse") && e.buttons === 0) {
				return
			}
			this._pointers[e.pointerId] = e;
			this._handlePointer(e, handler)
		}, this);
		obj["_leaflet_touchmove" + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false)
	}, _addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			delete this._pointers[e.pointerId];
			this._handlePointer(e, handler)
		}, this);
		obj["_leaflet_touchend" + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false)
	}});
	L.Map.mergeOptions({touchZoom: L.Browser.touch && !L.Browser.android23, bounceAtZoomLimits: true, touchFractionalZoom: false});
	L.Map.TouchZoom = L.Handler.extend({addHooks: function () {
		L.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
	}, removeHooks: function () {
		L.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
	}, _onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
			return
		}
		var p1 = map.mouseEventToLayerPoint(e.touches[0]), p2 = map.mouseEventToLayerPoint(e.touches[1]), viewCenter = map._getCenterLayerPoint();
		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);
		this._moved = false;
		this._zooming = true;
		this._centerOffset = viewCenter.subtract(this._startCenter);
		if (map._panAnim) {
			map._panAnim.stop()
		}
		L.DomEvent.on(document, "touchmove", this._onTouchMove, this).on(document, "touchend", this._onTouchEnd, this);
		L.DomEvent.preventDefault(e)
	}, _onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) {
			return
		}
		var map = this._map, p1 = map.mouseEventToLayerPoint(e.touches[0]), p2 = map.mouseEventToLayerPoint(e.touches[1]);
		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);
		if (!map.options.bounceAtZoomLimits && (map.getZoom() === map.getMinZoom() && this._scale < 1 || map.getZoom() === map.getMaxZoom() && this._scale > 1)) {
			return
		}
		if (!this._moved) {
			map.fire("movestart").fire("zoomstart");
			this._moved = true
		}
		this.touchCenter = p1.add(p2)._divideBy(2);
		map.fire("touchzooming", {tag: "update", zoom: this._zoom, delta: this._delta, center: this.touchCenter, startPoint: this._startCenter});
		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);
		L.DomEvent.preventDefault(e)
	}, _updateOnMove: function () {
		var map = this._map;
		this._center = map.layerPointToLatLng(this._getTargetCenter());
		this._zoom = map.getScaleZoom(this._scale);
		map._animateZoom(this._center, this._zoom)
	}, _onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return
		}
		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);
		L.DomEvent.off(document, "touchmove", this._onTouchMove).off(document, "touchend", this._onTouchEnd);
		var map = this._map;
		if (!this._map.options.touchFractionalZoom || this._zoom > map.getMaxZoom()) {
			var oldZoom = map.getZoom(), zoomDelta = this._zoom - oldZoom, finalZoom = map._limitZoom(zoomDelta > 0 ? Math.ceil(this._zoom) : Math.floor(this._zoom));
			map._animateZoom(this._center, finalZoom, true)
		} else {
			map._animateZoom(this._center, this._zoom, false);
			L.Util.cancelAnimFrame(this._animRequest);
			map._animatingZoom = false;
			L.DomUtil.removeClass(map._mapPane, "leaflet-zoom-anim");
			map._resetView(this._center, this._zoom, true, true);
			if (L.Draggable) {
				L.Draggable._disabled = false
			}
		}
	}, _getTargetCenter: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset)
	}});
	L.Map.addInitHook("addHandler", "touchZoom", L.Map.TouchZoom);
	L.Map.mergeOptions({tap: true, tapTolerance: 15});
	L.Map.Tap = L.Handler.extend({addHooks: function () {
		L.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
	}, removeHooks: function () {
		L.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
	}, _onDown: function (e) {
		if (!e.touches) {
			return
		}
		L.DomEvent.preventDefault(e);
		this._fireClick = true;
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return
		}
		var first = e.touches[0], el = first.target;
		this._startPos = this._newPos = new L.Point(first.clientX || first.pageX, first.clientY || first.pageY);
		if (el.tagName && el.tagName.toLowerCase() === "a") {
			L.DomUtil.addClass(el, "leaflet-active")
		}
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent("contextmenu", first)
			}
		}, this), 1e3);
		L.DomEvent.on(document, {touchmove: this._onMove, touchend: this._onUp}, this)
	}, _onUp: function (e) {
		clearTimeout(this._holdTimeout);
		L.DomEvent.off(document, {touchmove: this._onMove, touchend: this._onUp}, this);
		if (this._fireClick && e && e.changedTouches) {
			var first = e.changedTouches[0], el = first.target;
			if (el && el.tagName && el.tagName.toLowerCase() === "a") {
				L.DomUtil.removeClass(el, "leaflet-active")
			}
			if (this._isTapValid()) {
				this._simulateEvent("click", first)
			}
		}
	}, _isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
	}, _onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX || first.pageX, first.clientY || first.pageY)
	}, _simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent("MouseEvents");
		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;
		simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
		e.target.dispatchEvent(simulatedEvent)
	}});
	if (L.Browser.touch && !L.Browser.pointer) {
		L.Map.addInitHook("addHandler", "tap", L.Map.Tap)
	}
	L.Map.mergeOptions({boxZoom: true});
	L.Map.BoxZoom = L.Handler.extend({initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane
	}, addHooks: function () {
		L.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
	}, removeHooks: function () {
		L.DomEvent.off(this._container, "mousedown", this._onMouseDown, this)
	}, moved: function () {
		return this._moved
	}, _onMouseDown: function (e) {
		this._moved = false;
		if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
			return false
		}
		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();
		this._startPoint = this._map.mouseEventToContainerPoint(e);
		L.DomEvent.on(document, {mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown}, this)
	}, _onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;
			this._box = L.DomUtil.create("div", "leaflet-zoom-box", this._container);
			L.DomUtil.addClass(this._container, "leaflet-crosshair");
			this._map.fire("boxzoomstart")
		}
		this._point = this._map.mouseEventToContainerPoint(e);
		var bounds = new L.Bounds(this._point, this._startPoint), size = bounds.getSize();
		L.DomUtil.setPosition(this._box, bounds.min);
		this._box.style.width = size.x + "px";
		this._box.style.height = size.y + "px"
	}, _finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, "leaflet-crosshair")
		}
		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();
		L.DomEvent.off(document, {mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown}, this)
	}, _onMouseUp: function () {
		this._finish();
		if (!this._moved) {
			return
		}
		var bounds = new L.LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
		this._map.fitBounds(bounds).fire("boxzoomend", {boxZoomBounds: bounds})
	}, _onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish()
		}
	}});
	L.Map.addInitHook("addHandler", "boxZoom", L.Map.BoxZoom);
	L.Map.mergeOptions({keyboard: true, keyboardPanOffset: 80, keyboardZoomOffset: 1});
	L.Map.Keyboard = L.Handler.extend({keyCodes: {left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 173]}, initialize: function (map) {
		this._map = map;
		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset)
	}, addHooks: function () {
		var container = this._map._container;
		if (container.tabIndex === -1) {
			container.tabIndex = "0"
		}
		L.DomEvent.on(container, {focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown}, this);
		this._map.on({focus: this._addHooks, blur: this._removeHooks}, this)
	}, removeHooks: function () {
		this._removeHooks();
		L.DomEvent.off(this._map._container, {focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown}, this);
		this._map.off({focus: this._addHooks, blur: this._removeHooks}, this)
	}, _onMouseDown: function () {
		if (this._focused) {
			return
		}
		var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
		this._map._container.focus();
		window.scrollTo(left, top)
	}, _onFocus: function () {
		this._focused = true;
		this._map.fire("focus")
	}, _onBlur: function () {
		this._focused = false;
		this._map.fire("blur")
	}, _setPanOffset: function (pan) {
		var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0]
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0]
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan]
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan]
		}
	}, _setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom
		}
	}, _addHooks: function () {
		L.DomEvent.on(document, "keydown", this._onKeyDown, this)
	}, _removeHooks: function () {
		L.DomEvent.off(document, "keydown", this._onKeyDown, this)
	}, _onKeyDown: function (e) {
		var key = e.keyCode, map = this._map;
		if (key in this._panKeys) {
			if (map._panAnim && map._panAnim._inProgress) {
				return
			}
			map.panBy(this._panKeys[key]);
			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds)
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key])
		} else {
			return
		}
		L.DomEvent.stop(e)
	}});
	L.Map.addInitHook("addHandler", "keyboard", L.Map.Keyboard);
	L.Handler.MarkerDrag = L.Handler.extend({initialize: function (marker) {
		this._marker = marker
	}, addHooks: function () {
		var icon = this._marker._icon;
		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon)
		}
		this._draggable.on({dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd}, this).enable();
		L.DomUtil.addClass(icon, "leaflet-marker-draggable")
	}, removeHooks: function () {
		this._draggable.off({dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd}, this).disable();
		L.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
	}, moved: function () {
		return this._draggable && this._draggable._moved
	}, _onDragStart: function () {
		this._marker.closePopup().fire("movestart").fire("dragstart")
	}, _onDrag: function () {
		var marker = this._marker, shadow = marker._shadow, iconPos = L.DomUtil.getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos)
		}
		marker._latlng = latlng;
		marker.fire("move", {latlng: latlng}).fire("drag")
	}, _onDragEnd: function (e) {
		this._marker.fire("moveend").fire("dragend", e)
	}});
	L.Control = L.Class.extend({options: {position: "topright"}, initialize: function (options) {
		L.setOptions(this, options)
	}, getPosition: function () {
		return this.options.position
	}, setPosition: function (position) {
		var map = this._map;
		if (map) {
			map.removeControl(this)
		}
		this.options.position = position;
		if (map) {
			map.addControl(this)
		}
		return this
	}, getContainer: function () {
		return this._container
	}, addTo: function (map) {
		this._map = map;
		var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
		L.DomUtil.addClass(container, "leaflet-control");
		if (pos.indexOf("bottom") !== -1) {
			corner.insertBefore(container, corner.firstChild)
		} else {
			corner.appendChild(container)
		}
		return this
	}, remove: function () {
		L.DomUtil.remove(this._container);
		if (this.onRemove) {
			this.onRemove(this._map)
		}
		this._map = null;
		return this
	}, _refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus()
		}
	}});
	L.control = function (options) {
		return new L.Control(options)
	};
	L.Map.include({addControl: function (control) {
		control.addTo(this);
		return this
	}, removeControl: function (control) {
		control.remove();
		return this
	}, _initControlPos: function () {
		var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = L.DomUtil.create("div", l + "control-container", this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + " " + l + hSide;
			corners[vSide + hSide] = L.DomUtil.create("div", className, container)
		}

		createCorner("top", "left");
		createCorner("top", "right");
		createCorner("bottom", "left");
		createCorner("bottom", "right")
	}, _clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer)
	}});
	L.Control.Zoom = L.Control.extend({options: {position: "topleft", zoomInText: "+", zoomInTitle: "Zoom in", zoomOutText: "-", zoomOutTitle: "Zoom out"}, onAdd: function (map) {
		var zoomName = "leaflet-control-zoom", container = L.DomUtil.create("div", zoomName + " leaflet-bar"), options = this.options;
		this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + "-in", container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + "-out", container, this._zoomOut);
		this._updateDisabled();
		map.on("zoomend zoomlevelschange", this._updateDisabled, this);
		return container
	}, onRemove: function (map) {
		map.off("zoomend zoomlevelschange", this._updateDisabled, this)
	}, _zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1)
	}, _zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1)
	}, _createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create("a", className, container);
		link.innerHTML = html;
		link.href = "#";
		link.title = title;
		L.DomEvent.on(link, "mousedown dblclick", L.DomEvent.stopPropagation).on(link, "click", L.DomEvent.stop).on(link, "click", fn, this).on(link, "click", this._refocusOnMap, this);
		return link
	}, _updateDisabled: function () {
		var map = this._map, className = "leaflet-disabled";
		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);
		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className)
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className)
		}
	}});
	L.Map.mergeOptions({zoomControl: true});
	L.Map.addInitHook(function () {
		if (this.options.zoomControl) {
			this.zoomControl = new L.Control.Zoom;
			this.addControl(this.zoomControl)
		}
	});
	L.control.zoom = function (options) {
		return new L.Control.Zoom(options)
	};
	L.Control.Attribution = L.Control.extend({options: {position: "bottomright", prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'}, initialize: function (options) {
		L.setOptions(this, options);
		this._attributions = {}
	}, onAdd: function (map) {
		this._container = L.DomUtil.create("div", "leaflet-control-attribution");
		L.DomEvent.disableClickPropagation(this._container);
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution())
			}
		}
		this._update();
		return this._container
	}, setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this
	}, addAttribution: function (text) {
		if (!text) {
			return
		}
		if (!this._attributions[text]) {
			this._attributions[text] = 0
		}
		this._attributions[text]++;
		this._update();
		return this
	}, removeAttribution: function (text) {
		if (!text) {
			return
		}
		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update()
		}
		return this
	}, _update: function () {
		if (!this._map) {
			return
		}
		var attribs = [];
		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i)
			}
		}
		var prefixAndAttribs = [];
		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix)
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(", "))
		}
		this._container.innerHTML = prefixAndAttribs.join(" | ")
	}});
	L.Map.mergeOptions({attributionControl: true});
	L.Map.addInitHook(function () {
		if (this.options.attributionControl) {
			this.attributionControl = (new L.Control.Attribution).addTo(this)
		}
	});
	L.control.attribution = function (options) {
		return new L.Control.Attribution(options)
	};
	L.Control.Scale = L.Control.extend({options: {position: "bottomleft", maxWidth: 100, metric: true, imperial: true}, onAdd: function (map) {
		var className = "leaflet-control-scale", container = L.DomUtil.create("div", className), options = this.options;
		this._addScales(options, className + "-line", container);
		map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
		map.whenReady(this._update, this);
		return container
	}, onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
	}, _addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create("div", className, container)
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create("div", className, container)
		}
	}, _update: function () {
		var map = this._map, y = map.getSize().y / 2;
		var maxMeters = L.CRS.Earth.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));
		this._updateScales(maxMeters)
	}, _updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters)
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters)
		}
	}, _updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
		this._updateScale(this._mScale, label, meters / maxMeters)
	}, _updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + " mi", miles / maxMiles)
		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + " ft", feet / maxFeet)
		}
	}, _updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) - 10 + "px";
		scale.innerHTML = text
	}, _getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
		return pow10 * d
	}});
	L.control.scale = function (options) {
		return new L.Control.Scale(options)
	};
	L.Control.Layers = L.Control.extend({options: {collapsed: true, position: "topright", autoZIndex: true}, initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);
		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;
		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i)
		}
		for (i in overlays) {
			this._addLayer(overlays[i], i, true)
		}
	}, onAdd: function () {
		this._initLayout();
		this._update();
		return this._container
	}, addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return this._update()
	}, addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return this._update()
	}, removeLayer: function (layer) {
		layer.off("add remove", this._onLayerChange, this);
		delete this._layers[L.stamp(layer)];
		return this._update()
	}, _initLayout: function () {
		var className = "leaflet-control-layers", container = this._container = L.DomUtil.create("div", className);
		container.setAttribute("aria-haspopup", true);
		if (!L.Browser.touch) {
			L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container)
		} else {
			L.DomEvent.on(container, "click", L.DomEvent.stopPropagation)
		}
		var form = this._form = L.DomUtil.create("form", className + "-list");
		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {mouseover: this._expand, mouseout: this._collapse}, this)
			}
			var link = this._layersLink = L.DomUtil.create("a", className + "-toggle", container);
			link.href = "#";
			link.title = "Layers";
			if (L.Browser.touch) {
				L.DomEvent.on(link, "click", L.DomEvent.stop).on(link, "click", this._expand, this)
			} else {
				L.DomEvent.on(link, "focus", this._expand, this)
			}
			L.DomEvent.on(form, "click", function () {
				setTimeout(L.bind(this._onInputClick, this), 0)
			}, this);
			this._map.on("click", this._collapse, this)
		} else {
			this._expand()
		}
		this._baseLayersList = L.DomUtil.create("div", className + "-base", form);
		this._separator = L.DomUtil.create("div", className + "-separator", form);
		this._overlaysList = L.DomUtil.create("div", className + "-overlays", form);
		container.appendChild(form)
	}, _addLayer: function (layer, name, overlay) {
		layer.on("add remove", this._onLayerChange, this);
		var id = L.stamp(layer);
		this._layers[id] = {layer: layer, name: name, overlay: overlay};
		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex)
		}
	}, _update: function () {
		if (!this._container) {
			return
		}
		this._baseLayersList.innerHTML = "";
		this._overlaysList.innerHTML = "";
		var baseLayersPresent, overlaysPresent, i, obj;
		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay
		}
		this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
		return this
	}, _onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update()
		}
		var overlay = this._layers[L.stamp(e.target)].overlay;
		var type = overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
		if (type) {
			this._map.fire(type, e.target)
		}
	}, _createRadioElement: function (name, checked) {
		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
		var radioFragment = document.createElement("div");
		radioFragment.innerHTML = radioHtml;
		return radioFragment.firstChild
	}, _addItem: function (obj) {
		var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
		if (obj.overlay) {
			input = document.createElement("input");
			input.type = "checkbox";
			input.className = "leaflet-control-layers-selector";
			input.defaultChecked = checked
		} else {
			input = this._createRadioElement("leaflet-base-layers", checked)
		}
		input.layerId = L.stamp(obj.layer);
		L.DomEvent.on(input, "click", this._onInputClick, this);
		var name = document.createElement("span");
		name.innerHTML = " " + obj.name;
		label.appendChild(input);
		label.appendChild(name);
		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);
		return label
	}, _onInputClick: function () {
		var inputs = this._form.getElementsByTagName("input"), input, layer, hasLayer;
		this._handlingClick = true;
		for (var i = 0, len = inputs.length; i < len; i++) {
			input = inputs[i];
			layer = this._layers[input.layerId].layer;
			hasLayer = this._map.hasLayer(layer);
			if (input.checked && !hasLayer) {
				this._map.addLayer(layer)
			} else if (!input.checked && hasLayer) {
				this._map.removeLayer(layer)
			}
		}
		this._handlingClick = false;
		this._refocusOnMap()
	}, _expand: function () {
		L.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
	}, _collapse: function () {
		L.DomUtil.removeClass(this._container, "leaflet-control-layers-expanded")
	}});
	L.control.layers = function (baseLayers, overlays, options) {
		return new L.Control.Layers(baseLayers, overlays, options)
	};
	L.PosAnimation = L.Evented.extend({run: function (el, newPos, duration, easeLinearity) {
		this.stop();
		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;
		this.fire("start");
		el.style[L.DomUtil.TRANSITION] = "all " + (duration || .25) + "s cubic-bezier(0,0," + (easeLinearity || .5) + ",1)";
		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);
		L.Util.falseFn(el.offsetWidth);
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50)
	}, stop: function () {
		if (!this._inProgress) {
			return
		}
		this._newPos = this._getPos();
		L.DomUtil.setPosition(this._el, this._newPos);
		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth)
	}, _onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return
		}
		this._el._leaflet_pos = stepPos;
		this.fire("step")
	}, _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/, _getPos: function () {
		var left, top, matches, el = this._el, style = window.getComputedStyle(el);
		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) {
				return
			}
			left = parseFloat(matches[1]);
			top = parseFloat(matches[2])
		} else {
			left = parseFloat(style.left);
			top = parseFloat(style.top)
		}
		return new L.Point(left, top, true)
	}, _onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		if (!this._inProgress) {
			return
		}
		this._inProgress = false;
		this._el.style[L.DomUtil.TRANSITION] = "";
		this._el._leaflet_pos = this._newPos;
		clearInterval(this._stepTimer);
		this.fire("step").fire("end")
	}});
	L.Map.include({setView: function (center, zoom, options) {
		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};
		if (this._panAnim) {
			this._panAnim.stop()
		}
		if (this._loaded && !options.reset && options !== true) {
			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan)
			}
			var animated = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
			if (animated) {
				clearTimeout(this._sizeTimer);
				return this
			}
		}
		this._resetView(center, zoom);
		return this
	}, panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};
		if (!offset.x && !offset.y) {
			return this
		}
		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation;
			this._panAnim.on({step: this._onPanTransitionStep, end: this._onPanTransitionEnd}, this)
		}
		if (!options.noMoveStart) {
			this.fire("movestart")
		}
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || .25, options.easeLinearity)
		} else {
			this._rawPanBy(offset);
			this.fire("move").fire("moveend")
		}
		return this
	}, _onPanTransitionStep: function () {
		this.fire("move")
	}, _onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim");
		this.fire("moveend")
	}, _tryAnimatedPan: function (center, options) {
		var offset = this._getCenterOffset(center)._floor();
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
			return false
		}
		this.panBy(offset, options);
		return true
	}});
	L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({run: function (el, newPos, duration, easeLinearity) {
		this.stop();
		this._el = el;
		this._inProgress = true;
		this._duration = duration || .25;
		this._easeOutPower = 1 / Math.max(easeLinearity || .5, .2);
		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date;
		this.fire("start");
		this._animate()
	}, stop: function () {
		if (!this._inProgress) {
			return
		}
		this._step();
		this._complete()
	}, _animate: function () {
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step()
	}, _step: function () {
		var elapsed = +new Date - this._startTime, duration = this._duration * 1e3;
		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration))
		} else {
			this._runFrame(1);
			this._complete()
		}
	}, _runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);
		this.fire("step")
	}, _complete: function () {
		L.Util.cancelAnimFrame(this._animId);
		this._inProgress = false;
		this.fire("end")
	}, _easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower)
	}});
	L.Map.mergeOptions({zoomAnimation: true, zoomAnimationThreshold: 4});
	var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;
	if (zoomAnimated) {
		L.Map.addInitHook(function () {
			this._zoomAnimated = this.options.zoomAnimation;
			if (this._zoomAnimated) {
				L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
			}
		})
	}
	L.Map.include(!zoomAnimated ? {} : {_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
			this._onZoomTransitionEnd();
			this._endZoomUpdating()
		}
	}, _nothingToAnimate: function () {
		return!this._container.getElementsByClassName("leaflet-zoom-animated").length
	}, _tryAnimatedZoom: function (center, zoom, options) {
		if (this._animatingZoom) {
			return true
		}
		options = options || {};
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
			return false
		}
		var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);
		if (options.animate !== true && !this.getSize().contains(offset)) {
			return false
		}
		this.fire("movestart").fire("zoomstart");
		this._animateZoom(center, zoom, true);
		return true
	}, _animateZoom: function (center, zoom, startAnim) {
		if (startAnim) {
			this._animatingZoom = true;
			this._animateToCenter = center;
			this._animateToZoom = zoom;
			if (L.Draggable) {
				L.Draggable._disabled = true
			}
			L.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim");
			this._startZoomUpdating()
		}
		this.fire("zoomanim", {center: center, zoom: zoom, scale: this.getZoomScale(zoom), origin: this.latLngToLayerPoint(center), offset: this._getCenterOffset(center).multiplyBy(-1)})
	}, _onZoomTransitionEnd: function () {
		this._animatingZoom = false;
		L.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim");
		this._resetView(this._animateToCenter, this._animateToZoom, true, true);
		if (L.Draggable) {
			L.Draggable._disabled = false
		}
	}, _startZoomUpdating: function () {
		console.log("Start zoom updating");
		var self = this;
		(function loop() {
			self.anim = window.requestAnimationFrame(loop);
			self.fire("zooming")
		}).bind(self)()
	}, _endZoomUpdating: function () {
		console.log("End zoom updating");
		window.cancelAnimationFrame(this.anim)
	}});
	L.Map.include({zoomPanTo: function (targetCenter, targetZoom) {
		var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;
		var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from), rho = 1.42, rho2 = rho * rho;

		function r(i) {
			var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
			return Math.log(Math.sqrt(b * b + 1) - b)
		}

		function sinh(n) {
			return(Math.exp(n) - Math.exp(-n)) / 2
		}

		function cosh(n) {
			return(Math.exp(n) + Math.exp(-n)) / 2
		}

		function tanh(n) {
			return sinh(n) / cosh(n)
		}

		var r0 = r(0);

		function w(s) {
			return w0 * (cosh(r0) / cosh(r0 + rho * s))
		}

		function u(s) {
			return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2
		}

		function easeOut(t) {
			return 1 - Math.pow(1 - t, 1.5)
		}

		var start = Date.now(), S = (r(1) - r0) / rho, duration = 1e3 * S * .8;

		function frame() {
			var t = (Date.now() - start) / duration, s = easeOut(t) * S;
			if (t <= 1) {
				L.Util.requestAnimFrame(frame, this);
				this._resetView(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), true, true)
			} else {
				this._resetView(targetCenter, targetZoom, true, true)
			}
		}

		this.fire("zoomstart");
		frame.call(this)
	}});
	L.Map.include({_defaultLocateOptions: {timeout: 1e4, watch: false}, locate: function (options) {
		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);
		if (!navigator.geolocation) {
			this._handleGeolocationError({code: 0, message: "Geolocation not supported."});
			return this
		}
		var onResponse = L.bind(this._handleGeolocationResponse, this), onError = L.bind(this._handleGeolocationError, this);
		if (options.watch) {
			this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options)
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options)
		}
		return this
	}, stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId)
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false
		}
		return this
	}, _handleGeolocationError: function (error) {
		var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld()
		}
		this.fire("locationerror", {code: c, message: "Geolocation error: " + message + "."})
	}, _handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new L.LatLng(lat, lng), latAccuracy = 180 * pos.coords.accuracy / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * lat), bounds = L.latLngBounds([lat - latAccuracy, lng - lngAccuracy], [lat + latAccuracy, lng + lngAccuracy]), options = this._locateOptions;
		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom)
		}
		var data = {latlng: latlng, bounds: bounds, timestamp: pos.timestamp};
		for (var i in pos.coords) {
			if (typeof pos.coords[i] === "number") {
				data[i] = pos.coords[i]
			}
		}
		this.fire("locationfound", data)
	}})
})(window, document);
var touches = [];
var tuio = {cursors: [], _data: {}, _touchstart: function (touch) {
	this._create_event("touchstart", touch, {})
}, _touchmove: function (touch) {
	this._create_event("touchmove", touch, {})
}, _touchend: function (touch) {
	this._create_event("touchend", touch, {})
}, _create_event: function (name, touch, attrs) {
	var evt = document.createEvent("CustomEvent");
	evt.initEvent(name, true, true);
	evt.touches = this.cursors;
	evt.targetTouches = this._get_target_touches(touch.target);
	evt.changedTouches = [touch];
	for (var attr in attrs) {
		if (attrs.hasOwnProperty(attr)) {
			evt[attr] = attrs[attr]
		}
	}
	if (touch.target) {
		touch.target.dispatchEvent(evt)
	} else {
		document.dispatchEvent(evt)
	}
}, _get_target_touches: function (element) {
	var targetTouches = [];
	for (var i = 0; i < this.cursors.length; i++) {
		var touch = this.cursors[i];
		if (touch.target == element) {
			targetTouches.push(touch)
		}
	}
	return targetTouches
}, callback: function (type, sid, fid, x, y, angle) {
	var data;
	if (type !== 3) {
		data = this._data[sid]
	} else {
		data = {sid: sid, fid: fid};
		this._data[sid] = data
	}
	data.identifier = sid;
	data.pageX = data.clientX = data.screenX = window.innerWidth * x;
	data.pageY = data.clientY = data.screenY = window.innerHeight * y;
	data.target = document.elementFromPoint(data.pageX, data.pageY);
	switch (type) {
		case 3:
			this.cursors.push(data);
			this._touchstart(data);
			break;
		case 4:
			this._touchmove(data);
			break;
		case 5:
			this.cursors.splice(this.cursors.indexOf(data), 1);
			this._touchend(data);
			break;
		default:
			break
	}
	if (type === 5) {
		delete this._data[sid]
	}
}};
function tuio_callback(type, sid, fid, x, y, angle) {
	tuio.callback(type, sid, fid, x, y, angle)
}
(function () {
	var namespace = MAIN.namespace("MAIN.app");
	if (namespace.NavigatorArea === undefined) {
		namespace.NavigatorArea = function () {
		};
		var p = namespace.NavigatorArea.prototype;
		p.$box;
		p.zoomSize = 1;
		p.$mm;
		p.mainmap;
		p.prevPerc = 0;
		p.prevPoint;
		p.draggingBox = false;
		p.boundMouseMove;
		var map = this.mainmap;
		var smallestMapSize = {width: 1024, height: 320};
		var smallestMapSizeAdjusted;
		var largestMapSize = {width: 8192, height: 2560};
		var navigatorSize = {width: 333, height: 104};
		p.init = function (minimap, mainmap) {
			this.$mm = minimap;
			this.mainmap = mainmap;
			this.$box = $(".minimap-box");
			console.log(this + " initialised.");
			this.mainmap.on("zoomstart zoomend zoomlevelschange drag moveend resize move zooming", function (e) {
				this.update()
			}.bind(this));
			this.prevPoint = {x: 0, y: 0};
			this.initDraggableBox()
		};
		p.initDraggableBox = function () {
			this.boundMouseUp = this.boxMouseUp.bind(this);
			this.boundMouseDown = this.boxMouseDown.bind(this);
			this.boundMouseMove = this.boxMouseMove.bind(this);
			this.$mm.bind("touchstart mousedown", this.boundMouseDown)
		};
		p.boxMouseDown = function (e) {
			console.log("dragging box");
			$(document).bind("touchend mouseup", this.boundMouseUp);
			this.$mm.bind("touchmove mousemove", this.boundMouseMove);
			this.calculateBoxDrag(e)
		};
		p.boxMouseMove = function (e) {
			this.calculateBoxDrag(e)
		};
		p.boxMouseUp = function (e) {
			console.log("drag box end");
			$(document).unbind("touchend mouseup", this.boundMouseUp);
			this.$mm.unbind("touchmove mousemove", this.boundMouseMove)
		};
		p.calculateBoxDrag = function (e) {
			var offset = this.$mm.offset();
			var coords = RHYTHM.Utils.Tools.getCoords(e.originalEvent);
			var mapRatio = largestMapSize.height / largestMapSize.width;
			var mapWidth = $(".low-res-map").width();
			var mapHeight = mapWidth * mapRatio;
			var boxW = this.$box.width();
			var boxH = this.$box.height();
			var x = RHYTHM.Utils.Tools.mapRange(coords.x - offset.left, 0, 333, 0, mapWidth);
			var y = RHYTHM.Utils.Tools.mapRange(coords.y - offset.top, 0, 104, 0, mapHeight);
			var offsetY = (mapWidth - mapHeight) / 2;
			this.mainmap.setView(this.mainmap.unproject(L.point(x, y + offsetY)), this.mainmap.getZoom(), {reset: true})
		};
		p.update = function (data) {
			var touchZoom = data !== undefined;
			var touchZoomUpdate = touchZoom && data.tagc == "update";
			var touchZoomEnd = touchZoom && data.tag == "end";
			var zoomedOutPerc = RHYTHM.Utils.Tools.getPercentageAtValueBetween(this.mainmap.windowMinZoom, this.mainmap.getMaxZoom(), touchZoom ? data.zoom : this.mainmap.getZoom());
			var mapRatio = largestMapSize.height / largestMapSize.width;
			var mapWidth = $(".low-res-map").width();
			var mapHeight = mapWidth * mapRatio;
			var percDiff;
			if (touchZoom) {
				percDiff = zoomedOutPerc - this.prevPerc;
				var prevMapWidth = mapWidth;
				mapWidth = mapWidth + mapWidth * percDiff;
				mapHeight = mapHeight + mapHeight * percDiff
			}
			var padding = 4;
			this.$box.width(Math.min(navigatorSize.width, navigatorSize.width * window.innerWidth / mapWidth) - padding);
			this.$box.height(Math.min(navigatorSize.height, navigatorSize.height * window.innerHeight / mapHeight) - padding);
			var navRatioX = navigatorSize.width / mapWidth;
			var navRatioY = navigatorSize.height / mapHeight;
			var mapOffset = $(".low-res-map").offset();
			var mapX = Math.min(Math.max(0, -mapOffset.left * navRatioX), navigatorSize.width - this.$box.width() - padding);
			var mapTopOffset = mapOffset.top + (mapWidth - mapHeight) / 2;
			var mapY = Math.min(Math.max(0, -mapTopOffset * navRatioX), navigatorSize.height - this.$box.height() - padding);
			if (!touchZoom) {
				this.$box.css({left: mapX, top: mapY});
				this.prevPerc = zoomedOutPerc;
				this.prevPoint.x = mapX;
				this.prevPoint.y = mapY
			} else {
				var r = 333 / mapWidth;
				mapX = this.prevPoint.x - data.delta.x * r;
				mapY = this.prevPoint.y - data.delta.y * r;
				if (touchZoomEnd) {
					this.prevPoint.x = mapX;
					this.prevPoint.y = mapY;
					this.prevPerc = zoomedOutPerc
				}
				this.$box.css({left: mapX, top: mapY})
			}
		};
		p.toString = function () {
			return"LeafletMiniMapBox"
		}
	}
})();
(function () {
	var namespace = MAIN.namespace("MAIN.app");
	if (namespace.Navigator === undefined) {
		namespace.Navigator = function () {
		};
		var p = namespace.Navigator.prototype;
		p.mainmap;
		p.$mm;
		p.mmBox;
		p.init = function (mainmap) {
			this.mainmap = mainmap;
			this.$mm = $(".minimap");
			this.mmBox = new namespace.NavigatorArea;
			this.mmBox.init(this.$mm, this.mainmap);
			console.log(this + " initialised.")
		};
		p.toString = function () {
			return"Navigator"
		}
	}
})();
(function () {
	var namespace = MAIN.namespace("MAIN.app");
	if (namespace.Map === undefined) {
		namespace.Map = function () {
		};
		var p = namespace.Map.prototype;
		p.mapRectSize = 8192;
		p.actualMapHeight = 2560;
		p.imageURL = "img/map_jpg/{z}/map_{x}_{y}.jpg";
		p.mapName = "ommeganck";
		p.minZoom = 17;
		p.maxZoom = 20;
		p.mapBoundsOffsetY;
		p.imageLayer;
		p.map;
		p.nav;
		p.windowMinZoom;
		p.init = function () {
			this.createMap();
			this.createNavigator();
			this.addEventListeners();
			$(window).resize()
		};
		p.createMap = function () {
			this.mapBoundsOffsetY = (this.mapRectSize - this.actualMapHeight) * .5;
			this.imageLayer = new L.TileLayer(this.imageURL, {newMinZoom: this.minZoom, minZoom: this.minZoom, maxZoom: this.maxZoom, detectRetina: false});
			var mapProps = {crs: L.CRS.Simple, center: [0, 0], zoomControl: false, layers: [this.imageLayer], fadeAnimation: true, fractionalZoom: true, attributionControl: false, zoom: 17, boxZoom: false, snapZoom: false, updateOnMove: true, zoomAnimation: true, scrollWheelFractionalZoom: true, touchFractionalZoom: true};
			if (window.UsingDesktopTouchscreen) {
			}
			this.map = new L.map(this.mapName, mapProps);
			var southWest = this.map.unproject([0, this.mapRectSize], this.map.getMaxZoom());
			var northEast = this.map.unproject([this.mapRectSize, 0], this.map.getMaxZoom());
			var fullImageBounds = new L.LatLngBounds([southWest, northEast]);
			this.map.fitBounds(fullImageBounds);
			var maxSouthWest = this.map.unproject([0, this.mapRectSize - this.mapBoundsOffsetY], this.map.getMaxZoom());
			var maxNorthEast = this.map.unproject([this.mapRectSize, this.mapBoundsOffsetY], this.map.getMaxZoom());
			var relevantImageBounds = new L.LatLngBounds([maxSouthWest, maxNorthEast]);
			this.map.setMaxBounds(relevantImageBounds);
			this.setupTouchableButtonWithRollover($(".zoom-in"), $("a.zoom-in-button"), 61, function () {
				var tempZoomSetting = this.map._zoomAnimated;
				this.map._zoomAnimated = false;
				this.map.zoomIn(.1);
				this.map._zoomAnimated = tempZoomSetting
			}.bind(this));
			this.setupTouchableButtonWithRollover($(".zoom-out"), $("a.zoom-out-button"), 61, function () {
				var tempZoomSetting = this.map._zoomAnimated;
				this.map._zoomAnimated = false;
				this.map.zoomOut(.1);
				this.map._zoomAnimated = tempZoomSetting
			}.bind(this));
			this.imageLayer.options.bounds = relevantImageBounds;
			var topPane = this.map.createPane("leaflet-top-pane", this.map.getPanes().mapPane);
			var topLayer = this.imageLayer.addTo(this.map);
			topPane.appendChild(topLayer.getContainer());
			topLayer.setZIndex(9);
			var imageUrl = "img/map_low_res.jpg";
			var lowResImg = L.imageOverlay(imageUrl, fullImageBounds, {customClassName: "low-res-map"});
			lowResImg.addTo(this.map);
			this.map.on("resize", function () {
				console.log("resize");
				var maxSouthWest = this.map.unproject([0, this.mapRectSize - this.mapBoundsOffsetY], this.map.getMaxZoom());
				var maxNorthEast = this.map.unproject([this.mapRectSize, this.mapBoundsOffsetY], this.map.getMaxZoom());
				var relevantImageBounds = new L.LatLngBounds([maxSouthWest, maxNorthEast]);
				this.map.fitBounds(relevantImageBounds);
				this.map.options.newMinZoom = Math.max(this.minZoom, this.map.windowMinZoom)
			}.bind(this))
		};
		p.createNavigator = function (map) {
			this.nav = new namespace.Navigator;
			this.nav.init(this.map)
		};
		p.setupTouchableButtonWithRollover = function (container, el, hoverY, buttonAction) {
			var action = buttonAction.bind(this);
			var anim = null;
			container.bind("touchstart mousedown", function () {
				el.css("background-position", "0px " + hoverY + "px");
				(function loop() {
					anim = window.requestAnimationFrame(loop);
					action()
				})()
			});
			$(document).bind("touchend mouseup", function () {
				el.css("background-position", "0px 0px");
				window.cancelAnimationFrame(anim)
			})
		};
		p.addEventListeners = function () {
			$(window).resize(this.onResize.bind(this))
		};
		p.onResize = function () {
			$("#" + this.mapName).height(window.innerHeight);
			this.map.invalidateSize()
		}
	}
})();
MAIN.init = function () {
	var app = MAIN.namespace("MAIN.app");
	var appManager = new app.Map;
	appManager.init()
};
$(function () {
	MAIN.init()
});